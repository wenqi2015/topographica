<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>topo.base.simulation &mdash; Topographica</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.9.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/custom.js"></script>
    <link rel="shortcut icon" href="../../../_static/topo-favicon.ico"/>
    <link rel="top" title="Topographica" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>

<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>



<li><ul class="parents">



          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li>

</ul></li>


      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for topo.base.simulation</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A general-purpose Simulation class for discrete events.</span>

<span class="sd">The Simulation object is the central object of a simulation.  It</span>
<span class="sd">handles the simulation clock time and maintains communication between</span>
<span class="sd">the components of the simulation.</span>

<span class="sd">A simulation is structured as a directed graph of event-processing</span>
<span class="sd">nodes called EventProcessors (EPs).  EventProcessors generate</span>
<span class="sd">data-carrying Events, which are routed through the graph to other</span>
<span class="sd">EventProcessors via delayed connections.  Most objects in the</span>
<span class="sd">simulation will be a subclass of EventProcessor, customized to provide</span>
<span class="sd">some specific behavior.</span>

<span class="sd">There are different subclasses of Event, each doing different types of</span>
<span class="sd">computation, and each can contain any arbitrary Python data.  A</span>
<span class="sd">simulation begins by giving each EventProcessor an opportunity to send</span>
<span class="sd">any initial events.  It then proceeds by processing and delivering</span>
<span class="sd">events to EventProcessors in time order.  After all events for the</span>
<span class="sd">current time are processed, the simulation gives each EventProcessor a</span>
<span class="sd">chance to do any final computation, after which simulation time skips</span>
<span class="sd">to the time of the earliest event remaining in the queue.</span>


<span class="sd">PORTS</span>

<span class="sd">All connections between EPs are tagged with a source port and a</span>
<span class="sd">destination port.  Ports are internal addresses that EPs can use to</span>
<span class="sd">distinguish between inputs and outputs.  A port specifier can be any</span>
<span class="sd">hashable Python object.  If not specified, the input and output ports</span>
<span class="sd">for a connection default to None.</span>

<span class="sd">src_ports distinguish different types of output that an EP may</span>
<span class="sd">produce. When sending output, the EP must call self.send_output()</span>
<span class="sd">separately for each port.  dest_ports distinguish different types of</span>
<span class="sd">input an EP may receive and process.  The EP is free to interpret the</span>
<span class="sd">input port designation on an incoming event in any way it chooses.</span>

<span class="sd">An example dest_port might be for an EP that receives &#39;ordinary&#39;</span>
<span class="sd">neural activity on the default port, and receives a separate</span>
<span class="sd">modulatory signal that influences learning.  The originator of the</span>
<span class="sd">modulatory signal might have a connection to the EP with dest_port =</span>
<span class="sd">&#39;Modulation&#39;.  Multiple ports can be grouped by a dest EP by assuming</span>
<span class="sd">a convention that the keys are tuples,</span>
<span class="sd">e.g. (&#39;JointNormalize&#39;,&#39;Group1&#39;), (&#39;JointNormalize&#39;,&#39;Group2&#39;).</span>

<span class="sd">An example src_port use might be an EP that sends different events to</span>
<span class="sd">itself than it sends out to other EPs.  In this case the self</span>
<span class="sd">connections might have src_port = &#39;Recurrent&#39;, and probably also a</span>
<span class="sd">special dest_port.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">param</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">bisect</span>

<span class="kn">from</span> <span class="nn">holoviews.interface.collector</span> <span class="kn">import</span> <span class="n">AttrDict</span>

<span class="c">#: Default path to the current simulation, from main</span>
<span class="c">#: Only to be used by script_repr(), to allow it to generate</span>
<span class="c">#: a runnable script</span>
<span class="n">_simulation_path</span><span class="o">=</span><span class="s">&quot;topo.sim&quot;</span>




<div class="viewcode-block" id="EventProcessor"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EventProcessor">[docs]</a><span class="k">class</span> <span class="nc">EventProcessor</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for EventProcessors, i.e. objects that can accept and</span>
<span class="sd">    handle events.  This base class handles the basic mechanics of</span>
<span class="sd">    connections and sending events, and stores both incoming and outgoing</span>
<span class="sd">    connections.</span>

<span class="sd">    The dest_ports attribute specifies which dest_ports are supported</span>
<span class="sd">    by this class; subclasses can augment or change this list if they</span>
<span class="sd">    wish.  The special value dest_ports=None means to accept</span>
<span class="sd">    connections to any dest_port, while dest_ports=[None,&#39;Trigger&#39;]</span>
<span class="sd">    means that only connections to port None or port &#39;Trigger&#39; are</span>
<span class="sd">    accepted.</span>

<span class="sd">    Similarly, the src_ports attribute specifies which src_ports will</span>
<span class="sd">    be given output by this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__abstract</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">dest_ports</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="n">src_ports</span><span class="o">=</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an EventProcessor.</span>

<span class="sd">        Note that just creating an EventProcessor does not mean it is</span>
<span class="sd">        part of the simulation (i.e. it is not in the simulation&#39;s list</span>
<span class="sd">        of EventProcessors, and it will not have its start() method called).</span>
<span class="sd">        To add an EventProcessor e to a simulation s, simply do</span>
<span class="sd">        s[&#39;name_of_e&#39;]=e. At this point, e&#39;s &#39;name&#39; attribute will be set</span>
<span class="sd">        to &#39;name_of_e&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EventProcessor</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="c"># A subclass could use another data stucture to optimize operations</span>
        <span class="c"># specific to itself, if it also overrides _dest_connect().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_connections</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">simulation</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_port_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">portlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the given key matches any port on the given list.</span>

<span class="sd">        In the default implementation, a port is considered a match if</span>
<span class="sd">        the port is == to the key, but subclasses of EventProcessor can</span>
<span class="sd">        override this to allow weaker forms of matching.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">portlist</span>

    <span class="c"># if extra parameters are required for an EP subclass, a</span>
    <span class="c"># dictionary could be added to Simulation.connect() to hold</span>
    <span class="c"># them, and passed on here</span>
    <span class="k">def</span> <span class="nf">_src_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">conn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the specified connection to the list of outgoing connections.</span>
<span class="sd">        Should only be called from Simulation.connect().</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_ports</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_port_match</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">src_port</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">src_ports</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not on the list of ports provided for outgoing connections for </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">src_port</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_ports</span><span class="p">)))</span>

        <span class="c"># CB: outgoing connection must be uniquely named among others</span>
        <span class="c"># going to the same destination.</span>
        <span class="k">for</span> <span class="n">existing_connection</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">existing_connection</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="n">conn</span><span class="o">.</span><span class="n">name</span> <span class="ow">and</span> <span class="n">existing_connection</span><span class="o">.</span><span class="n">dest</span><span class="o">==</span><span class="n">conn</span><span class="o">.</span><span class="n">dest</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;A connection out of an EventProcessor must have a unique name among connections to a particular destination; &quot;</span><span class="si">%s</span><span class="s">&quot; out of </span><span class="si">%s</span><span class="s"> into </span><span class="si">%s</span><span class="s"> already exists&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">conn</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="c"># CB: alternative: outgoing connection must have a unique name</span>
<span class="c">##         for existing_connection in self.out_connections:</span>
<span class="c">##             if existing_connection.name==conn.name:</span>
<span class="c">##                 raise ValueError(&#39;A connection out of an EventProcessor must have a unique name; &quot;%s&quot; out of %s already exists&#39;%(conn.name,self.name))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">out_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_dest_connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">conn</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the specified connection to the list of incoming connections.</span>
<span class="sd">        Should only be called from Simulation.connect().</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest_ports</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_port_match</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">dest_port</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dest_ports</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> is not on the list of ports allowed for incoming connections for </span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">dest_port</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest_ports</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">existing_connection</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">existing_connection</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">conn</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;A connection into an EventProcessor must have a unique name; &quot;</span><span class="si">%s</span><span class="s">&quot; into </span><span class="si">%s</span><span class="s"> already exists&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">in_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend dir() to include in_connections of an EventProcessor.</span>
<span class="sd">        Useful for software that examines the list of possible</span>
<span class="sd">        in_connections, such as tab completion in IPython.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">default_dir</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">default_dir</span> <span class="o">+</span> <span class="p">[</span><span class="n">conn</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_connections</span><span class="p">]))</span>


    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide a simpler attribute-like syntax for accessing the</span>
<span class="sd">        in_connections of an EventProcessor (e.g. obj.conn, for</span>
<span class="sd">        in_connection &quot;conn&quot; of EventProcessor obj).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span> <span class="k">return</span> <span class="n">conn</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span>


<div class="viewcode-block" id="EventProcessor.start"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EventProcessor.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the simulation when the EventProcessor is added to</span>
<span class="sd">        the simulation.</span>

<span class="sd">        If an EventProcessor needs to have any code run when it is</span>
<span class="sd">        added to the simulation, the code can be put into this method</span>
<span class="sd">        in the subclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="c">### JABALERT: Should change send_output to accept a list of src_ports, not a single src_port.</span></div>
<div class="viewcode-block" id="EventProcessor.send_output"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EventProcessor.send_output">[docs]</a>    <span class="k">def</span> <span class="nf">send_output</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">src_port</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Send some data out to all connections on the given src_port.</span>
<span class="sd">        The data is deepcopied before it is sent out, to ensure that</span>
<span class="sd">        future changes to the data are not reflected in events from</span>
<span class="sd">        the past.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out_conns_on_src_port</span> <span class="o">=</span> <span class="p">[</span><span class="n">conn</span> <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_connections</span>
                                 <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_port_match</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">src_port</span><span class="p">,[</span><span class="n">src_port</span><span class="p">])]</span>

        <span class="n">data</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">out_conns_on_src_port</span><span class="p">:</span>
            <span class="c">#self.verbose(&quot;Sending output on src_port %s via connection %s to %s&quot; % (str(src_port), conn.name, conn.dest.name))</span>
            <span class="n">e</span><span class="o">=</span><span class="n">EPConnectionEvent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation</span><span class="o">.</span><span class="n">convert_to_time_type</span><span class="p">(</span><span class="n">conn</span><span class="o">.</span><span class="n">delay</span><span class="p">)</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span><span class="n">conn</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">deep_copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simulation</span><span class="o">.</span><span class="n">enqueue_event</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="EventProcessor.input_event"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EventProcessor.input_event">[docs]</a>    <span class="k">def</span> <span class="nf">input_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">conn</span><span class="p">,</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the simulation when an EPConnectionEvent is delivered;</span>
<span class="sd">        the EventProcessor should process the data somehow.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

</div>
<div class="viewcode-block" id="EventProcessor.process_current_time"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EventProcessor.process_current_time">[docs]</a>    <span class="k">def</span> <span class="nf">process_current_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by the simulation before advancing the simulation</span>
<span class="sd">        time.  Allows the event processor to do any computation that</span>
<span class="sd">        requires that all events for this time have been delivered.</span>
<span class="sd">        Computations performed in this method should not generate any</span>
<span class="sd">        events with a zero time delay, or else causality could be</span>
<span class="sd">        violated. (By default, does nothing.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="EventProcessor.script_repr"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EventProcessor.script_repr">[docs]</a>    <span class="k">def</span> <span class="nf">script_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">imports</span><span class="o">=</span><span class="p">[],</span><span class="n">prefix</span><span class="o">=</span><span class="s">&quot;    &quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a runnable command for creating this EventProcessor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_simulation_path</span><span class="o">+</span><span class="s">&quot;[&#39;&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&quot;&#39;]=&quot;</span><span class="o">+</span>\
        <span class="nb">super</span><span class="p">(</span><span class="n">EventProcessor</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">script_repr</span><span class="p">(</span><span class="n">imports</span><span class="o">=</span><span class="n">imports</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">)</span>



</div></div>
<div class="viewcode-block" id="EventProcessorParameter"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EventProcessorParameter">[docs]</a><span class="k">class</span> <span class="nc">EventProcessorParameter</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parameter whose value can be any EventProcessor instance.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="n">EventProcessor</span><span class="p">(),</span><span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EventProcessorParameter</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">obj</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">EventProcessor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Parameter must be an EventProcessor.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">EventProcessorParameter</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__set__</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>

</div>
<span class="kn">from</span> <span class="nn">param</span> <span class="kn">import</span> <span class="n">parameterized</span>

<div class="viewcode-block" id="EPConnection"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EPConnection">[docs]</a><span class="k">class</span> <span class="nc">EPConnection</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    EPConnection stores basic information for a connection between</span>
<span class="sd">    two EventProcessors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c">## JPALERT: This type-checking is redundant, since</span>
<span class="c">##     Simulation.connect() only allows the user to create connections</span>
<span class="c">##     between existing simulation objects, which must be EPs.  Type</span>
<span class="c">##     checking here means that it is impossible to ever instantiate</span>
<span class="c">##     an EPConnection in any situation (including debugging) w/o</span>
<span class="c">##     making src and dest be EPs.  However, there is nothing I can</span>
<span class="c">##     find that requires that the src or dest be EPs.  While some</span>
<span class="c">##     *subclasses* of EPConnection (such as Projection) do require</span>
<span class="c">##     that their src and dest support the interfaces of some</span>
<span class="c">##     *subclasses* of EventProcessor (e.g. Sheet.activity), there is</span>
<span class="c">##     no reason that those objects have to be EPs, per se.  IMO,</span>
<span class="c">##     excessive type checking removes much of the power of using a</span>
<span class="c">##     dynamic language like Python.</span>

<span class="c">##     src = EventProcessorParameter(default=None,constant=True,precedence=0.10,doc=</span>
<span class="c">##        &quot;&quot;&quot;The EventProcessor from which messages originate.&quot;&quot;&quot;)</span>

<span class="c">##     dest = EventProcessorParameter(default=None,constant=True,precedence=0.11,doc=</span>
<span class="c">##        &quot;&quot;&quot;The EventProcessor to which messages are delivered.&quot;&quot;&quot;)</span>

    <span class="n">src</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">precedence</span><span class="o">=</span><span class="mf">0.10</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
       <span class="sd">&quot;&quot;&quot;The EventProcessor from which messages originate.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">dest</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">precedence</span><span class="o">=</span><span class="mf">0.11</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
       <span class="sd">&quot;&quot;&quot;The EventProcessor to which messages are delivered.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">src_port</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">precedence</span><span class="o">=</span><span class="mf">0.20</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
       <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       Identifier that can be used to distinguish different types of outgoing connections.</span>

<span class="sd">       EventProcessors that generate only a single type of</span>
<span class="sd">       outgoing event will typically use a src_port of None.  However,</span>
<span class="sd">       if multiple types of communication are meaningful, the</span>
<span class="sd">       EventProcessor can accept other values for src_port.  It is up</span>
<span class="sd">       to the src EventProcessor to deliver appropriate data to each</span>
<span class="sd">       port, and to declare what will be sent over that port.</span>
<span class="sd">       &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">dest_port</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">precedence</span><span class="o">=</span><span class="mf">0.21</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
       <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">       Identifier that can be used to distinguish different types of incoming connections.</span>

<span class="sd">       EventProcessors that accept only a single type of incoming</span>
<span class="sd">       event will typically use a src_port of None.  However, if</span>
<span class="sd">       multiple types of communication are meaningful, the</span>
<span class="sd">       EventProcessor can accept other values for dest_port.  It is up</span>
<span class="sd">       to the dest EventProcessor to process the data appropriately</span>
<span class="sd">       for each port, and to define what is expected to be sent to</span>
<span class="sd">       that port.</span>
<span class="sd">       &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="c"># Should the lower bound be exclusive?</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">None</span><span class="p">),</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">       Simulation time between generation of an Event by the src and delivery to the dest.</span>
<span class="s">       Should normally be nonzero, to represent a causal with a well-defined ordering</span>
<span class="s">       of events.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">private</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
       <span class="sd">&quot;&quot;&quot;Set to true if this connection is for internal use only, not to be manipulated by a user.&quot;&quot;&quot;</span><span class="p">)</span>


    <span class="c"># CEBALERT: should be reimplemented. It&#39;s difficult to understand,</span>
    <span class="c"># and contains the same code twice. But it does work.</span>
<div class="viewcode-block" id="EPConnection.remove"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EPConnection.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove this connection from its src&#39;s list of out_connections and its</span>
<span class="sd">        dest&#39;s list of in_connections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># remove from EPs that have this as in_connection</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_del</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">in_conn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">in_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">in_conn</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">to_del</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_del</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">in_connections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c"># remove from EPs that have this as out_connection</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_del</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">out_conn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">out_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out_conn</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">to_del</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_del</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">out_connections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="EPConnection.script_repr"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EPConnection.script_repr">[docs]</a>    <span class="k">def</span> <span class="nf">script_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">imports</span><span class="o">=</span><span class="p">[],</span><span class="n">prefix</span><span class="o">=</span><span class="s">&quot;    &quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a runnable command for creating this connection.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">private</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;&quot;</span>

        <span class="n">settings</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span> <span class="c"># There may be a better way to figure out which parameters specify classes</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="nb">object</span><span class="p">):</span>
                    <span class="n">rep</span><span class="o">=</span><span class="n">val</span><span class="o">.</span><span class="n">__name__</span>
                    <span class="c"># Generate import statement</span>
                    <span class="n">cls</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">__name__</span>
                    <span class="n">mod</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">__module__</span>
                    <span class="n">imports</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;from </span><span class="si">%s</span><span class="s"> import </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span><span class="n">cls</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span><span class="o">==</span><span class="s">&quot;src&quot;</span> <span class="ow">or</span> <span class="n">name</span><span class="o">==</span><span class="s">&quot;dest&quot;</span><span class="p">:</span>
                    <span class="n">rep</span><span class="o">=</span><span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rep</span> <span class="o">=</span> <span class="n">parameterized</span><span class="o">.</span><span class="n">script_repr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">imports</span><span class="p">,</span><span class="n">prefix</span><span class="p">,</span><span class="n">settings</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rep</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">settings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">=</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">rep</span><span class="p">))</span>

        <span class="c"># add import statement</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__module__</span>
        <span class="n">imports</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;from </span><span class="si">%s</span><span class="s"> import </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span><span class="n">cls</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_simulation_path</span><span class="o">+</span><span class="s">&quot;.connect(&#39;&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s">&quot;&#39;,&#39;&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">name</span><span class="o">+</span> \
               <span class="s">&quot;&#39;,connection_type=&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">+</span> \
               <span class="s">&quot;,</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span><span class="n">prefix</span><span class="o">+</span><span class="p">(</span><span class="s">&quot;,</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">+</span><span class="n">prefix</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span>


<span class="c"># CB: event is not a Parameterized because of a (small) performance hit.</span></div></div>
<div class="viewcode-block" id="Event"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Event">[docs]</a><span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Hierarchy of classes for storing simulation events of various types.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cause some computation to be performed, deliver a message, etc.,</span>
<span class="sd">        as appropriate for each subtype of Event.  Should be passed the</span>
<span class="sd">        simulation object, to allow access to .time() etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ev</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements event comparison by time, allowing sorting,</span>
<span class="sd">        and queue maintenance  using bisect module or minheap</span>
<span class="sd">        implementations, if needed.</span>

<span class="sd">        NOTE: identity comparisons should always be done using the</span>
<span class="sd">        &#39;is&#39; operator, not &#39;==&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">ev</span><span class="o">.</span><span class="n">time</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">ev</span><span class="o">.</span><span class="n">time</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

</div>
<div class="viewcode-block" id="EPConnectionEvent"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EPConnectionEvent">[docs]</a><span class="k">class</span> <span class="nc">EPConnectionEvent</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An Event for delivery to an EPConnection.</span>

<span class="sd">    Provides access to a data field, which can be used for anything</span>
<span class="sd">    the src wants to provide, and a link to the connection over which</span>
<span class="sd">    it has arrived, so that the dest can determine what to do with the</span>
<span class="sd">    data.</span>

<span class="sd">    By default, the data is deepcopied before being added to this</span>
<span class="sd">    instance for safety (e.g. so that future changes to data</span>
<span class="sd">    structures do not affect messages arriving from the past).</span>
<span class="sd">    However, if you can ensure that the copying is not</span>
<span class="sd">    necessary (e.g. if you deepcoy before sending a set of</span>
<span class="sd">    identical messages), then you can pass deep_copy=False</span>
<span class="sd">    to avoid the copy.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">conn</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">deep_copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EPConnectionEvent</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="n">EPConnection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">deep_copy</span> <span class="k">else</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">input_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;EPConnectionEvent(time=&quot;</span><span class="o">+</span><span class="sb">`self.time`</span><span class="o">+</span><span class="s">&quot;,conn=&quot;</span><span class="o">+</span><span class="sb">`self.conn`</span><span class="o">+</span><span class="s">&quot;)&quot;</span>

</div>
<div class="viewcode-block" id="CommandEvent"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.CommandEvent">[docs]</a><span class="k">class</span> <span class="nc">CommandEvent</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An Event consisting of a command string to execute.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">command_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the event to the simulation.</span>

<span class="sd">        Raises an exception if the command_string contains a syntax</span>
<span class="sd">        error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command_string</span> <span class="o">=</span> <span class="n">command_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__test</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CommandEvent</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;CommandEvent(time=&quot;</span><span class="o">+</span><span class="sb">`self.time`</span><span class="o">+</span><span class="s">&quot;, command_string=&#39;&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">command_string</span><span class="o">+</span><span class="s">&quot;&#39;)&quot;</span>


<div class="viewcode-block" id="CommandEvent.script_repr"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.CommandEvent.script_repr">[docs]</a>    <span class="k">def</span> <span class="nf">script_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">imports</span><span class="o">=</span><span class="p">[],</span><span class="n">prefix</span><span class="o">=</span><span class="s">&quot;    &quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a runnable command for creating this CommandEvent.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_simulation_path</span><span class="o">+</span><span class="s">&#39;.schedule_command(&#39;</span>\
               <span class="o">+</span><span class="sb">`self.time`</span><span class="o">+</span><span class="s">&#39;,&quot;&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">command_string</span><span class="o">+</span><span class="s">&#39;&quot;)&#39;</span>

</div>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        exec&#39;s the command_string in __main__.__dict__.</span>

<span class="sd">        Be sure that any required items will be present in</span>
<span class="sd">        __main__.__dict__; in particular, consider what will be present</span>
<span class="sd">        after the network is saved and restored. For instance, results of</span>
<span class="sd">        scripts you have run, or imports they make---all currently</span>
<span class="sd">        available in __main__.__dict__---will not be saved with the</span>
<span class="sd">        network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Presumably here to avoid importing __main__ into the rest of the file</span>
        <span class="kn">import</span> <span class="nn">__main__</span>

        <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;CommandEvent&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s">&quot;Running command </span><span class="si">%s</span><span class="s">&quot;</span> \
                                                         <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">command_string</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">exec</span> <span class="bp">self</span><span class="o">.</span><span class="n">command_string</span> <span class="ow">in</span> <span class="n">__main__</span><span class="o">.</span><span class="n">__dict__</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error in scheduled command:&quot;</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">__test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check for SyntaxErrors in the command.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">command_string</span><span class="p">,</span><span class="s">&quot;CommandString&quot;</span><span class="p">,</span><span class="s">&quot;single&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Error in scheduled command:&quot;</span>
            <span class="k">raise</span>

</div>
<div class="viewcode-block" id="FunctionEvent"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.FunctionEvent">[docs]</a><span class="k">class</span> <span class="nc">FunctionEvent</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Event that executes a given function function(*args,**kw).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">fn</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FunctionEvent</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">kw</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sim</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;FunctionEvent(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">,*</span><span class="si">%s</span><span class="s">,**</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="sb">`self.time`</span><span class="p">,</span><span class="sb">`self.fn`</span><span class="p">,</span><span class="sb">`self.args`</span><span class="p">,</span><span class="sb">`self.kw`</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="EventSequence"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.EventSequence">[docs]</a><span class="k">class</span> <span class="nc">EventSequence</span><span class="p">(</span><span class="n">Event</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Event that contains a sequence of other events to be scheduled and</span>
<span class="sd">    executed.</span>

<span class="sd">    The .time attributes of the events in the sequence are interpreted</span>
<span class="sd">    as offsets relative to the start time of the sequence itself.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">sequence</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EventSequence</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sim</span><span class="p">):</span>

        <span class="c"># Enqueue all the events in the sequence, offsetting their</span>
        <span class="c"># times from the current time</span>
        <span class="n">sched_time</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">:</span>
            <span class="n">new_ev</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>
            <span class="n">sched_time</span> <span class="o">+=</span> <span class="n">ev</span><span class="o">.</span><span class="n">time</span>
            <span class="n">new_ev</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">sched_time</span>
            <span class="n">sim</span><span class="o">.</span><span class="n">enqueue_event</span><span class="p">(</span><span class="n">new_ev</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;EventSequence(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="sb">`self.time`</span><span class="p">,</span><span class="sb">`self.sequence`</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="PeriodicEventSequence"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.PeriodicEventSequence">[docs]</a><span class="k">class</span> <span class="nc">PeriodicEventSequence</span><span class="p">(</span><span class="n">EventSequence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An EventSequence that reschedules itself periodically</span>

<span class="sd">    Takes a period argument that determines how often the sequence</span>
<span class="sd">    will be scheduled.   If the length of the sequence is longer than</span>
<span class="sd">    the period, then the length of the sequence will be used as the period.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">## JPHACKALERT: This should really be refactored into a</span>
    <span class="c">## PeriodicEvent class that periodically executes a single event,</span>
    <span class="c">## then the user can construct a periodic sequence using a</span>
    <span class="c">## combination of PeriodicEvent and EventSequence.  This would</span>
    <span class="c">## change the behavior if the sequence length is longer than the</span>
    <span class="c">## period, but I&#39;m not sure how important that is, and it might</span>
    <span class="c">## actually be useful the other way.</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">period</span><span class="p">,</span><span class="n">sequence</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PeriodicEventSequence</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="n">sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sim</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PeriodicEventSequence</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>

        <span class="c"># Find the timed length of the sequence</span>
        <span class="n">seq_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seq_length</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">:</span>
            <span class="c"># If the sequence is shorter than the period, then reschedule</span>
            <span class="c"># the sequence to occur again after the period</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If the sequence is longer than the period, then</span>
            <span class="c"># reschedule to start after the sequence ends.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="n">seq_length</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">enqueue_event</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;PeriodicEventSequence(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="sb">`self.time`</span><span class="p">,</span><span class="sb">`self.period`</span><span class="p">,</span><span class="sb">`self.sequence`</span><span class="p">)</span>


<span class="c"># CB: code that previously existed in various places now collected</span>
<span class="c"># together. The original timing code was not properly tested, and the</span>
<span class="c"># current code has not been tested either: needs writing cleanly and</span>
<span class="c"># testing. This whole class is pretty difficult to follow.</span>
<span class="c">#</span>
<span class="c">### JP: Is it possible that some or all of this can be more cleanly</span>
<span class="c">### implemented using PeriodicEvents?</span>
</div>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span>
<div class="viewcode-block" id="SomeTimer"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.SomeTimer">[docs]</a><span class="k">class</span> <span class="nc">SomeTimer</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides a countdown timer for functions that run repeatedly.</span>

<span class="sd">    There are two distinct ways to use the timer.</span>

<span class="sd">    The first, via call_and_time(), is for calling some function every</span>
<span class="sd">    specified number of steps for a specified duration. Currently</span>
<span class="sd">    call_and_time() is used for timing calls to simulation.run() every</span>
<span class="sd">    1.0 steps for 100 iterations. See the Simulation class for an</span>
<span class="sd">    example of using the timer in this way.</span>

<span class="sd">    The second, via call_fixed_num_times(), is for calling some</span>
<span class="sd">    function repeatedly a specified number of times. A case to use</span>
<span class="sd">    call_fixed_num_times() would be timing pattern presentations,</span>
<span class="sd">    where the number of times the pattern_presenter will be called is</span>
<span class="sd">    known in advance. Additionally, this method allows a list of</span>
<span class="sd">    arguments to be passed to the function (in this case, the</span>
<span class="sd">    permutation for each call).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># * parameters to control formatting?</span>
    <span class="c"># * the parameter types for some of the following could be more specific</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
        <span class="sd">&quot;&quot;&quot;Only relevant with call_and_time(), not call_fixed_num_times().</span>

<span class="sd">           Each iteration, func is called as func(step).</span>

<span class="sd">           For example, step=1 with func set to topo.sim.time would cause</span>
<span class="sd">           the simulation time to advance once per iteration.</span>

<span class="sd">           The default value (None) gives 50 iterations for any value of simulation_duration</span>
<span class="sd">           passed to call_and_time(simulation_duration).&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">estimate_interval</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
        <span class="sd">&quot;&quot;&quot;Interval in simulation time between estimates.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">instantiate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
        <span class="sd">&quot;&quot;&quot;Function to be timed.&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c">##     func_args = Parameter(default=None,instantiate=True,doc=</span>
<span class="c">##         &quot;&quot;&quot;Arguments passed to func at time of calling.&quot;&quot;&quot;)</span>

    <span class="n">simulation_time_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">instantiate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
        <span class="sd">&quot;&quot;&quot;Function that returns the simulation time.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">real_time_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">,</span><span class="n">instantiate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
        <span class="sd">&quot;&quot;&quot;Function that returns the wallclock time.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">receive_info</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span><span class="n">instantiate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
        <span class="sd">&quot;&quot;&quot;List of objects that will receive timing information.</span>
<span class="sd">        Each must have a timing_info() method.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">stop</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span>
        <span class="sd">&quot;&quot;&quot;If set to True, execution of func (and timing) will cease at the end of</span>
<span class="sd">        the current iteration.&quot;&quot;&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__pass_out_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">percent</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="n">remaining</span><span class="p">):</span>
        <span class="p">[</span><span class="n">thing</span><span class="p">(</span><span class="n">time</span><span class="p">,</span><span class="n">percent</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">duration</span><span class="p">,</span><span class="n">remaining</span><span class="p">)</span> <span class="k">for</span> <span class="n">thing</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">receive_info</span><span class="p">]</span>

    <span class="c"># CB: this used to say how long the operation took (in wallclock time)</span>

    <span class="k">def</span> <span class="nf">__measure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fduration</span><span class="p">,</span><span class="n">step</span><span class="p">,</span><span class="n">arg_list</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">arg_list</span><span class="p">:</span>
            <span class="c"># no list of arguments means not being called set number of times</span>
            <span class="n">fixed_num_calls</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fixed_num_calls</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">iters</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">fduration</span><span class="o">/</span><span class="n">step</span><span class="p">))</span>

        <span class="n">recenttimes</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fixed_num_calls</span><span class="p">:</span> <span class="n">arg_list</span><span class="o">=</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">*</span><span class="n">iters</span>

        <span class="n">simulation_starttime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_time_fn</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>
            <span class="n">recenttimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real_time_fn</span><span class="p">())</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">recenttimes</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">estimate_interval</span><span class="p">):</span>
                <span class="n">recenttimes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">length</span><span class="o">-=</span><span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">arg_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">percent</span> <span class="o">=</span> <span class="mf">100.0</span><span class="o">*</span><span class="n">i</span><span class="o">/</span><span class="n">iters</span>
            <span class="n">estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">iters</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">recenttimes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">recenttimes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">length</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__pass_out_info</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_time_fn</span><span class="p">(),</span>
                                 <span class="n">percent</span><span class="o">=</span><span class="n">percent</span><span class="p">,</span>
                                 <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                                 <span class="n">duration</span><span class="o">=</span><span class="n">fduration</span><span class="p">,</span>
                                 <span class="n">remaining</span><span class="o">=</span><span class="n">estimate</span><span class="p">)</span>

            <span class="c">## JABALERT: Needs to be fixed to avoid calling topo from base/</span>
            <span class="c">## HACK refresh windows for camera in simulation time</span>
            <span class="kn">import</span> <span class="nn">topo</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">topo</span><span class="p">,</span> <span class="s">&#39;guimain&#39;</span><span class="p">):</span>
                <span class="n">topo</span><span class="o">.</span><span class="n">guimain</span><span class="o">.</span><span class="n">refresh_activity_windows</span><span class="p">()</span>
            <span class="c">##</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span> <span class="k">break</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fixed_num_calls</span><span class="p">:</span>
                <span class="c"># ensure specified duration has been respected, since code above might not</span>
                <span class="c"># complete specified duration (integer number of iterations)</span>
                <span class="n">leftover</span> <span class="o">=</span> <span class="n">fduration</span><span class="o">+</span><span class="n">simulation_starttime</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_time_fn</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">leftover</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">leftover</span><span class="p">)</span>
            <span class="n">percent</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pass_out_info</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_time_fn</span><span class="p">(),</span>
                             <span class="n">percent</span><span class="o">=</span><span class="n">percent</span><span class="p">,</span>
                             <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
                             <span class="n">duration</span><span class="o">=</span><span class="n">fduration</span><span class="p">,</span>
                             <span class="n">remaining</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>



<div class="viewcode-block" id="SomeTimer.call_fixed_num_times"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.SomeTimer.call_fixed_num_times">[docs]</a>    <span class="k">def</span> <span class="nf">call_fixed_num_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">args_for_iterations</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call self.func(args_for_iterations[i]) for all i in args_for_iterations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__measure</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args_for_iterations</span><span class="p">),</span><span class="mf">1.0</span><span class="p">,</span><span class="n">arg_list</span><span class="o">=</span><span class="n">args_for_iterations</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="SomeTimer.call_and_time"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.SomeTimer.call_and_time">[docs]</a>    <span class="k">def</span> <span class="nf">call_and_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fduration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call self.func(self.step or fduration/50.0) for fduration.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># default to 50 steps unless someone set otherwise</span>
        <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="n">fduration</span><span class="o">/</span><span class="mf">50.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__measure</span><span class="p">(</span><span class="n">fduration</span><span class="p">,</span><span class="n">step</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">update_timer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">current_presentation</span><span class="p">,</span><span class="n">total_presentations</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">current_presentation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recenttimes</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">if</span> <span class="n">current_presentation</span> <span class="o">==</span> <span class="n">total_presentations</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">percent</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="n">estimate</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recenttimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real_time_fn</span><span class="p">())</span>

            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recenttimes</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">estimate_interval</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">recenttimes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">length</span><span class="o">-=</span><span class="mi">1</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">percent</span> <span class="o">=</span> <span class="mf">100.0</span><span class="o">*</span><span class="n">current_presentation</span><span class="o">/</span><span class="n">total_presentations</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">percent</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="n">estimate</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_presentations</span><span class="o">-</span><span class="n">current_presentation</span><span class="p">)</span><span class="o">*</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recenttimes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">recenttimes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">length</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__pass_out_info</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">current_presentation</span><span class="p">,</span>
                             <span class="n">percent</span><span class="o">=</span><span class="n">percent</span><span class="p">,</span>
                             <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                             <span class="n">duration</span><span class="o">=</span><span class="n">total_presentations</span><span class="p">,</span>
                             <span class="n">remaining</span><span class="o">=</span><span class="n">estimate</span><span class="p">)</span>



<span class="c"># CEBALERT: This singleton-producing mechanism is pretty complicated,</span>
<span class="c"># and it would be great if someone could simplify it. Getting all of</span>
<span class="c"># the behavior we want for e.g. Simulation is tricky, but there are</span>
<span class="c"># tests for it. Note that:</span>
<span class="c"># (1) There should only ever be one single Simulation instance for</span>
<span class="c">#     which register is True. Creating, copying, and unpickling</span>
<span class="c">#     need to take this into account.</span>
<span class="c"># (2) A Simulation instance for which register is False should</span>
<span class="c">#     behave the same as any normal Python object.</span>
<span class="c">#</span>
<span class="c"># For how to use, see topo.base.simulation.Simulation or</span>
<span class="c"># topo.misc.commandline.GlobalParams.</span></div>
<span class="k">class</span> <span class="nc">OptionalSingleton</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">_inst</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">singleton</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the single instance stored in _inst if singleton is</span>
<span class="sd">        True; otherwise, return a new instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">singleton</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_inst</span><span class="p">):</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">_inst</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
                <span class="n">cls</span><span class="o">.</span><span class="n">_inst</span><span class="o">.</span><span class="n">_singleton</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_inst</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_inst</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
            <span class="n">new_inst</span><span class="o">.</span><span class="n">_singleton</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">new_inst</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># An OptionalSingleton(singleton=False) instance is copied, while the</span>
        <span class="c"># OptionalSingleton(singleton=True) instance is not copied.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Ideally we&#39;d just call &quot;object.__copy__&quot;, but apparently</span>
            <span class="c"># there&#39;s no such method.</span>

            <span class="c"># CB: I *think* this is how to do a copy. Any better</span>
            <span class="c"># ideas?  Python&#39;s copy.copy() function calls an object&#39;s</span>
            <span class="c"># __reduce__ method and then reconstructs the object from</span>
            <span class="c"># that using copy._reconstruct().</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">)</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_obj</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_singleton</span><span class="p">)</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_obj</span>

    <span class="c"># CB: I might have bound __copy__ (&amp; __deepcopy__) just to the</span>
    <span class="c"># Simulation(singleton=True) instance to avoid the Simulation</span>
    <span class="c"># class having a __copy__ method at all, but copy() only checks</span>
    <span class="c"># the *class* for the existence of __copy__.</span>



<span class="c"># Simulation stores its events in a linear-time priority queue (i.e., a</span>
<span class="c"># sorted list.) For efficiency, e.g. for spiking neuron simulations,</span>
<span class="c"># we&#39;ll probably need to replace the linear priority queue with a more</span>
<span class="c"># efficient one.  Jeff has an O(log N) minheap implementation, but</span>
<span class="c"># there are likely to be many others to select from.</span>
<span class="c">#</span>
<div class="viewcode-block" id="Simulation"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation">[docs]</a><span class="k">class</span> <span class="nc">Simulation</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">,</span><span class="n">OptionalSingleton</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simulation class that uses a simple sorted event list (instead of</span>
<span class="sd">    e.g. a sched.scheduler object) to manage events and dispatching.</span>

<span class="sd">    Simulation is a singleton: there is only one instance of</span>
<span class="sd">    Simulation, no matter how many times it is instantiated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">register</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Whether or not to register this Simulation. If True, this</span>
<span class="s">        Simulation (when created explicitly or when unpickled)</span>
<span class="s">        will replace any existing registered Simulation (if one exists).</span>
<span class="s">        Thus only one Simulation with register=True can exist at</span>
<span class="s">        any one time, which makes it simpler to handle defining</span>
<span class="s">        and reloading a series of simulations without polluting the</span>
<span class="s">        memory space with unused simulations.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">startup_commands</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">instantiate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        List of string commands that will be exec&#39;d in</span>
<span class="s">        __main__.__dict__ (i.e. as if they were entered at the</span>
<span class="s">        command prompt) every time this simulation is unpickled</span>
<span class="s">        (and will be executed before the simulation is itself</span>
<span class="s">        unpickled).</span>

<span class="s">        For example, allows items to be imported before</span>
<span class="s">        scheduled_commands are run.</span>
<span class="s">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">time</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Callable</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">Dynamic</span><span class="o">.</span><span class="n">time_fn</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        The time object is a callable that can be set, incremented and</span>
<span class="s">        decremented with a chosen numeric type as necessary.</span>
<span class="s">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">time_printing_format</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%(_time)09.2f</span><span class="s">&quot;</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Format string to be used when the simulation time must be</span>
<span class="s">        formatted as a string, e.g. for display or for basename().</span>
<span class="s">        When the string is evaluated, the time will be available as</span>
<span class="s">        the attribute &#39;_time&#39;.</span>
<span class="s">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">basename_format</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%(name)s</span><span class="s">_</span><span class="si">%(timestr)s</span><span class="s">&quot;</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Format string to be used by the basename() function.</span>
<span class="s">        When the string is evaluated, the formatted time from</span>
<span class="s">        time_printing_format will be available as the attribute</span>
<span class="s">        &#39;timestr&#39;.</span>
<span class="s">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">eps_to_start</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">constant</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">forever</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Infinity</span><span class="p">()</span>

    <span class="c">### Simulation(register=True) is a singleton</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c"># There is only ever one instance of Simulation(register=True).</span>
    <span class="c"># This instance is stored in the &#39;_inst&#39; attribute; when __new__</span>
    <span class="c"># is called and register is True, this instance is created if it</span>
    <span class="c"># doesn&#39;t already exist, and returned otherwise. copying or</span>
    <span class="c"># deepcopying this instance returns the instance.</span>
    <span class="c">#</span>
    <span class="c"># For a Simulation with register False, calling __new__ results in</span>
    <span class="c"># a new object as usual for Python objects. copying and</span>
    <span class="c"># deepcopying returns a new Simulation with a copy or deepcopy</span>
    <span class="c"># (respectively) of the original Simulation&#39;s __dict__.</span>
    <span class="c">#</span>
    <span class="c"># See OptionalSingleton for more information.</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>

        <span class="c"># simulate behavior of a parameter for register</span>
        <span class="k">if</span> <span class="s">&#39;register&#39;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">register</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s">&#39;register&#39;</span><span class="p">]</span>
        <span class="c"># this elif shouldn&#39;t be required, but is needed for</span>
        <span class="c"># unpickling: OptionalSingleton&#39;s __getnewargs__ is called</span>
        <span class="c"># with register as the first argument (I don&#39;t know how else</span>
        <span class="c"># to set register on unpickling).</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">register</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">register</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">register</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">OptionalSingleton</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">register</span><span class="p">)</span>

        <span class="c"># CEBALERT: without removing references to the Sheets from</span>
        <span class="c"># from instances of Slice, those instances of Slice and the</span>
        <span class="c"># Sheets they refer to are never garbage collected.</span>
        <span class="c">#</span>
        <span class="c"># This temporary implementation of cleanup code explicitly</span>
        <span class="c"># removes references to Sheets from Slice instances for</span>
        <span class="c"># typical simulations.</span>
        <span class="c">#</span>
        <span class="c"># 1: Better than having cleanup code here would be to make a</span>
        <span class="c"># change to Slice, so that a Slice either doesn&#39;t have a</span>
        <span class="c"># reference to a Sheet, or doesn&#39;t hold onto that reference.</span>
        <span class="c">#</span>
        <span class="c"># 2: Some cleanup code will always be required here in</span>
        <span class="c"># Simulation.__new__: As well as removing references to Sheets</span>
        <span class="c"># from Slices, it is also necessary to remove references to</span>
        <span class="c"># sheets from Simulation&#39;s lists of EPs - otherwise the sheets</span>
        <span class="c"># are not garbage collected and memory usage will go up every</span>
        <span class="c"># time a new Simulation is created. This cleanup must be in</span>
        <span class="c"># Simulation.__new__ so that it runs whenever a simulation is</span>
        <span class="c"># created or unpickled (it can&#39;t be done e.g. in</span>
        <span class="c"># load_snapshot).</span>
        <span class="c">#</span>
        <span class="c"># 3: this particular implementation assumes the only instances</span>
        <span class="c"># of Slice are in ConnectionFields, which is true for our</span>
        <span class="c"># simulations. (This won&#39;t matter when the slice cleanup</span>
        <span class="c"># becomes unnecessary.)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="s">&#39;_cleanup&#39;</span><span class="p">):</span>
            <span class="n">n</span><span class="o">.</span><span class="n">_cleanup</span><span class="p">()</span>
        <span class="c"># if we don&#39;t collect() here (exactly here - not in _cleanup,</span>
        <span class="c"># and not later), gc seems to lose track of some objects and</span>
        <span class="c"># there is still a (smaller) memory increase with every call</span>
        <span class="c"># to load_snapshot()</span>
        <span class="kn">import</span> <span class="nn">gc</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">n</span>

    <span class="c"># CEBALERT: see gc alert in __new__()</span>
    <span class="k">def</span> <span class="nf">_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># will always be required: in case eps haven&#39;t been started</span>
        <span class="c"># so are still in the list</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;eps_to_start&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eps_to_start</span><span class="p">[:]</span><span class="o">=</span><span class="p">[]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;_event_processors&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">EP</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">EP</span><span class="o">.</span><span class="n">in_connections</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="s">&#39;_cleanup&#39;</span><span class="p">):</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">_cleanup</span><span class="p">()</span>
                <span class="c"># will always be required</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span>
                <span class="c"># (check when cleaning up existing mechanism for</span>
                <span class="c"># adding sheets e.g. sim[&#39;x&#39;]=sheet could first set</span>
                <span class="c"># sim[&#39;x&#39;] to None if there is already a sheet with</span>
                <span class="c"># name x...)</span>


    <span class="c"># CEBALERT: if we&#39;re keeping this, should have a better name</span>
<div class="viewcode-block" id="Simulation.convert_to_time_type"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.convert_to_time_type">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_time_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the supplied time to the Simulation&#39;s time_type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forever</span> <span class="k">if</span> <span class="n">time</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">forever</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">time_type</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>

    <span class="c"># Note that __init__ can still be called after the</span>
    <span class="c"># Simulation(register=True) instance has been created. E.g. with</span>
    <span class="c"># Simulation.register is True,</span>
    <span class="c">#   Simulation(name=&#39;A&#39;); Simulation(name=&#39;B&#39;)</span>
    <span class="c">#</span>
    <span class="c"># would leave the single Simulation(register=True) instance with</span>
    <span class="c"># name==&#39;B&#39;. This is because, as is usual in Python, __new__</span>
    <span class="c"># creates an instance of a class, while __init__ is subsequently</span>
    <span class="c"># given that instance (to initialize).</span>

</div>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a Simulation instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">views</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">register</span><span class="p">:</span>
            <span class="c"># Indicate that no specific name has been set</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">)</span>
            <span class="c"># Set up debugging messages to include the simulator time</span>
            <span class="n">param</span><span class="o">.</span><span class="n">parameterized</span><span class="o">.</span><span class="n">dbprint_prefix</span><span class="o">=</span> \
               <span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="s">&quot;Time: &quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">timestr</span><span class="p">()</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># CB: consider collections.deque? (PEP 290)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events_stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps_to_start</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">item_scale</span><span class="o">=</span><span class="mf">1.0</span> <span class="c"># this variable determines the size of each item in a diagram</span>

        <span class="c"># CB (this comment applies to SomeTimer!): make this a</span>
        <span class="c"># parameter for documentation? Otherwise nobody will know</span>
        <span class="c"># about being able to adjust step.</span>
        <span class="c">#</span>
        <span class="c"># we set step to 2 so that by default timing doesn&#39;t slow simulation too much. but</span>
        <span class="c"># e.g. leaving it as None would result in info at 2% increments of requested run duration,</span>
        <span class="c"># no matter what duration (0.005 or 5, etc).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">SomeTimer</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">,</span>
                               <span class="n">simulation_time_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span>

    <span class="nd">@model.setter</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setting a Model object automatically calls the setup method of</span>
<span class="sd">        the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="k">return</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Model object </span><span class="si">%r</span><span class="s"> is not callable&quot;</span> <span class="o">%</span> <span class="n">model</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Please supply an instantiated model object and not a Model class.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="n">model</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">name</span>


    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">item_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return item_name if it exists as an EventProcessor in</span>
<span class="sd">        the Simulation. See objects().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item_name</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Expected string (objects in the Simulation are indexed by name); </span><span class="si">%s</span><span class="s"> is a </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">item_name</span><span class="p">,</span><span class="nb">type</span><span class="p">(</span><span class="n">item_name</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">()[</span><span class="n">item_name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s">&quot;Simulation doesn&#39;t contain &#39;&quot;</span><span class="o">+</span><span class="n">item_name</span><span class="o">+</span><span class="s">&quot;&#39;.&quot;</span><span class="p">)</span>


    <span class="c"># CEBALERT: should this at least give a warning when an existing</span>
    <span class="c"># EP is replaced?</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ep_name</span><span class="p">,</span><span class="n">ep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add ep to the simulation, setting its name to ep_name.</span>
<span class="sd">        ep must be an EventProcessor.</span>

<span class="sd">        If ep_name already exists in the simulation, ep overwrites</span>
<span class="sd">        the original object (as for a dictionary).</span>

<span class="sd">        Note: EventProcessors do not necessarily have to be added to</span>
<span class="sd">        the simulation to be used, but otherwise they will not receive the</span>
<span class="sd">        start() message.  Adding a node to the simulation also sets the</span>
<span class="sd">        backlink node.simulation, so that the node can enqueue events</span>
<span class="sd">        and read the simulation time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ep_name</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Expected string for item name (EPs in the Simulation are indexed by name).&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span><span class="n">EventProcessor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Expected EventProcessor: objects in the Simulation must be EPs.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;EventProcessor &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; () already exists in the simulation and will not be added.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ep</span><span class="o">.</span><span class="n">initialized</span><span class="o">=</span><span class="bp">False</span>
            <span class="n">ep</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="n">ep_name</span>
            <span class="n">ep</span><span class="o">.</span><span class="n">initialized</span><span class="o">=</span><span class="bp">True</span>
            <span class="c"># deletes and overwrites any existing EP with the same name,</span>
            <span class="c"># silently, as if a dictionary</span>
            <span class="k">if</span> <span class="n">ep</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">ep</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span>
            <span class="n">ep</span><span class="o">.</span><span class="n">simulation</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eps_to_start</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ep</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span><span class="s">&#39;views&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">views</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">ep</span><span class="o">.</span><span class="n">views</span>


    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ep_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary-style deletion of EPs from the simulation; see __delete_ep().</span>

<span class="sd">        Deletes EP from simulation, plus connections that come into it and</span>
<span class="sd">        connections that go out of it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ep_name</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Expected string for item name (EPs in the Simulation are indexed by name).&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__delete_ep</span><span class="p">(</span><span class="n">ep_name</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__delete_ep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ep_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the specified EventProcessor from the simulation, plus</span>
<span class="sd">        delete connections that come into it and connections that go from it.</span>

<span class="sd">        (Used by &#39;del sim[ep_name]&#39; (as for a dictionary) to delete</span>
<span class="sd">        an event processor from the simulation.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ep</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span>

        <span class="c"># remove from simulation list of eps</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="p">[</span><span class="n">ep_name</span><span class="p">]</span>

        <span class="c"># remove out_conections that go to this ep</span>
        <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">in_connections</span><span class="p">:</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="c"># remove in_connections that come from this ep</span>
        <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">ep</span><span class="o">.</span><span class="n">out_connections</span><span class="p">:</span>
            <span class="n">conn</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">():</span> <span class="k">yield</span> <span class="n">obj</span>


    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extend dir() to include simulation objects as well.  Useful</span>
<span class="sd">        for software that examines the list of possible objects, such</span>
<span class="sd">        as tab completion in IPython.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">default_dir</span> <span class="o">=</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">default_dir</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>


    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide a simpler attribute-like syntax for accessing objects</span>
<span class="sd">        within a Simulation (e.g. sim.obj1, for an EventProcessor</span>
<span class="sd">        &quot;obj1&quot; in sim).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">==</span><span class="s">&#39;_event_processors&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">()[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>


<div class="viewcode-block" id="Simulation.timestr"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.timestr">[docs]</a>    <span class="k">def</span> <span class="nf">timestr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">specified_time</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the specified time (or the current time, if none</span>
<span class="sd">        specified) formatted using time.time_printing_format, which allows</span>
<span class="sd">        users to control how much precision, etc. is used for time</span>
<span class="sd">        displays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># CEBALERT: I doubt this gets all attributes. Does it get</span>
        <span class="c"># properties (not that there are any right now)?</span>
        <span class="n">all_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">())</span>
        <span class="n">all_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">specified_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">all_vars</span><span class="p">[</span><span class="s">&#39;_time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">specified_time</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">all_vars</span><span class="p">[</span><span class="s">&#39;_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;No time object available.&#39;</span><span class="p">)</span>

        <span class="n">timestr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_printing_format</span> <span class="o">%</span> <span class="n">all_vars</span>
        <span class="k">return</span> <span class="n">timestr</span>

</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Simulation.timestr_prop"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.timestr_prop">[docs]</a>    <span class="k">def</span> <span class="nf">timestr_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A property that simply returns self.timestr(); useful for setting the</span>
<span class="sd">        interactive command-line prompt.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestr</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Simulation.basename"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.basename">[docs]</a>    <span class="k">def</span> <span class="nf">basename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string suitable for labeling an object created</span>
<span class="sd">        by the current simulation at the current time.  By default</span>
<span class="sd">        this is simply the name of the simulation + &quot; &quot; +</span>
<span class="sd">        the result from evaluating the time_printing_format parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_param_values</span><span class="p">())</span>
        <span class="n">all_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
        <span class="n">all_vars</span><span class="p">[</span><span class="s">&#39;timestr&#39;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timestr</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename_format</span> <span class="o">%</span> <span class="n">all_vars</span>



    <span class="c"># Change current run() to _run(), and current run_and_time() to run()?</span>

    <span class="c"># CEBALERT: need to simplify duration/until code. Hiding &#39;until&#39; option</span>
    <span class="c"># until it&#39;s fixed (presumably nobody&#39;s using it).</span></div>
    <span class="k">def</span> <span class="nf">run_and_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">forever</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">duration</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">forever</span><span class="p">:</span>
            <span class="c"># CEBALERT: timing code not setup to handle indefinite durations</span>
            <span class="c"># (e.g. &#39;self.forever&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">call_and_time</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">setup_options</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">instantiate_options</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optionally regenerate the simulation specification and</span>
<span class="sd">        instantiate the model (when load is set to True). If</span>
<span class="sd">        setup_options is not None, a new specification will be created</span>
<span class="sd">        with the given options - see the docstring of Model.setup for</span>
<span class="sd">        more information.</span>

<span class="sd">        If load is set to True, the model is instantiated using the</span>
<span class="sd">        supplied instantiate options and verbose flag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span>
        <span class="k">if</span> <span class="n">setup_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">setup_options</span><span class="o">=</span><span class="n">setup_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">load</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">specification</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">specification</span><span class="p">(</span><span class="n">instantiate_options</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                     <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">load</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;No specification found on the self.model object&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Simulation.run"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">forever</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">forever</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process simulation events for the specified duration or until the</span>
<span class="sd">        specified time.</span>

<span class="sd">        Arguments:</span>

<span class="sd">          duration = length of simulation time to run. Default: run</span>
<span class="sd">          indefinitely while there are still events in the</span>
<span class="sd">          event_queue.</span>

<span class="sd">          until = maximum simulation time to simulate. Default: run</span>
<span class="sd">          indefinitely while there are still events in the event</span>
<span class="sd">          queue.</span>

<span class="sd">        If both duration and until are used, the one that is reached first will apply.</span>


<span class="sd">        Note that duration and until should be specified in a format suitable for</span>
<span class="sd">        conversion (coercion?) into the Simulation&#39;s _time_type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s">&quot;No model specified to the Simulation instance.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># CEBALERT: calls to topo.sim.run() within topo should use a</span>
        <span class="c"># string to specify the time rather than a float (since float</span>
        <span class="c"># is not compatible with all number types).</span>

        <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_time_type</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>

        <span class="c"># Use the until value of self.time if not explicitly specified</span>
        <span class="n">until</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_time_type</span><span class="p">(</span><span class="n">until</span><span class="p">)</span>
        <span class="c"># Initialize any EPs that haven&#39;t been started yet</span>
        <span class="c">#</span>
        <span class="c"># Anything that manipulates the event stack in some way</span>
        <span class="c"># (e.g. calls state_push() *must* ensure that this code has</span>
        <span class="c"># been executed first (i.e. the code must call topo.sim.run(0)</span>
        <span class="c"># before doing anything).  (Currently applies to</span>
        <span class="c"># pattern_present(), Test Pattern&#39;s Present button, and</span>
        <span class="c"># save_input_generators, but future code may need such calls</span>
        <span class="c"># as well.)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_to_start</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eps_to_start</span><span class="o">=</span><span class="p">[]</span>

        <span class="n">stop_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">duration</span><span class="p">,</span> <span class="n">until</span><span class="p">)</span>
        <span class="c"># Use time.until if it is between the current time and stop_time.</span>
        <span class="c"># This ensures self.time.until act only as a &#39;soft&#39; limit</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">until</span> <span class="o">&lt;=</span> <span class="n">stop_time</span><span class="p">):</span>
            <span class="n">stop_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">until</span>
        <span class="c"># Stops time going backward if until less than current time.</span>
        <span class="n">stop_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="k">if</span> <span class="n">stop_time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="k">else</span> <span class="n">stop_time</span>

        <span class="n">did_event</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="ow">and</span> <span class="p">(</span><span class="n">stop_time</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">forever</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">stop_time</span><span class="p">):</span>
            <span class="c"># Loop while there are events and it&#39;s not time to stop.</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">():</span>
                <span class="c"># Warn and then discard events scheduled *before* the current time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Discarding stale (unprocessed) event&#39;</span><span class="p">,</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">():</span>
                <span class="c"># Before moving on to the next time, do any processing</span>
                <span class="c"># necessary for the current time.  This is necessary only</span>
                <span class="c"># if some event has been delivered at the current time.</span>

                <span class="k">if</span> <span class="n">did_event</span><span class="p">:</span>
                    <span class="n">did_event</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="c">#self.debug(&quot;Time to sleep; next event time: %s&quot;,self.timestr(self.events[0].time))</span>
                    <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">ep</span><span class="o">.</span><span class="n">process_current_time</span><span class="p">()</span>

                <span class="c"># Set the time to the frontmost event.  Bear in mind</span>
                <span class="c"># that the front event may have been changed by the</span>
                <span class="c"># .process_current_time() calls.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Pop and call the event at the head of the queue.</span>
                <span class="n">event</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span><span class="s">&quot;Delivering </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">event</span><span class="p">))</span>
                <span class="n">event</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="n">did_event</span><span class="o">=</span><span class="bp">True</span>

        <span class="c"># The time needs updating if the events have not done it.</span>
        <span class="c">#if self.events and self.events[0].time &gt;= stop_time:</span>

        <span class="k">if</span> <span class="n">stop_time</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forever</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">stop_time</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Simulation.sleep"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.sleep">[docs]</a>    <span class="k">def</span> <span class="nf">sleep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">delay</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advance the simulator time by the specified amount.</span>
<span class="sd">        By default simply increments the _time value, but subclasses can</span>
<span class="sd">        override this method as they wish, e.g. to wait for an</span>
<span class="sd">        external real time clock to advance first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>
        <span class="n">time</span> <span class="o">+=</span> <span class="n">delay</span>
</div>
<div class="viewcode-block" id="Simulation.enqueue_event"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.enqueue_event">[docs]</a>    <span class="k">def</span> <span class="nf">enqueue_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enqueue an Event at an absolute simulation clock time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span><span class="n">Event</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="ow">or</span> <span class="n">event</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c"># The new event goes at the end of the event queue if there</span>
            <span class="c"># isn&#39;t a queue right now, or if it&#39;s later than the last</span>
            <span class="c"># event&#39;s time.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">event</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c"># If it&#39;s earlier than the first item it goes at the beginning.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">event</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Otherwise, it&#39;s inserted at the appropriate</span>
            <span class="c"># position somewhere inside the event queue.</span>
            <span class="c"># New events are enqueued after (right of) existing</span>
            <span class="c"># events with the same time, i.e. &#39;simultaneous&#39; events</span>
            <span class="c"># are executed FIFO.</span>
            <span class="n">bisect</span><span class="o">.</span><span class="n">insort_right</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">,</span><span class="n">event</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Simulation.schedule_command"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.schedule_command">[docs]</a>    <span class="k">def</span> <span class="nf">schedule_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">times</span><span class="p">,</span><span class="n">command_string</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a command to execute in __main__.__dict__ at the</span>
<span class="sd">        specified time.</span>

<span class="sd">        The command should be a string and times may be either a</span>
<span class="sd">        single time value or a list of times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">times</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">times</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="n">event</span> <span class="o">=</span> <span class="n">CommandEvent</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_to_time_type</span><span class="p">(</span><span class="n">time</span><span class="p">),</span> <span class="n">command_string</span><span class="o">=</span><span class="n">command_string</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">enqueue_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Simulation.state_push"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.state_push">[docs]</a>    <span class="k">def</span> <span class="nf">state_push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a copy of the current state of the simulation for later restoration.</span>

<span class="sd">        The saved copy includes all the events on the simulator stack</span>
<span class="sd">        (saved using event_push()).  Each EventProcessor is also asked</span>
<span class="sd">        to save its own state.  This operation is useful for testing</span>
<span class="sd">        something while being able to roll back to the original state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps_to_start</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_push</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ep</span><span class="o">.</span><span class="n">state_push</span><span class="p">()</span>

        <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="o">.</span><span class="n">state_push</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Simulation.state_pop"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.state_pop">[docs]</a>    <span class="k">def</span> <span class="nf">state_pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop the most recently saved state off the stack.</span>

<span class="sd">        See state_push() for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ep</span><span class="o">.</span><span class="n">state_pop</span><span class="p">()</span>

        <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="o">.</span><span class="n">state_pop</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Simulation.event_push"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.event_push">[docs]</a>    <span class="k">def</span> <span class="nf">event_push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a copy of the events queue for later restoration.</span>

<span class="sd">        Same as state_push(), but does not ask EventProcessors to save</span>
<span class="sd">        their state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># CBALERT: does it make more sense to put the original events onto the</span>
        <span class="c"># stack, and replace self.events with the copies? Not sure this makes</span>
        <span class="c"># any practical difference currently.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events_stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(),[</span><span class="n">copy</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">]))</span>

</div>
<div class="viewcode-block" id="Simulation.event_pop"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.event_pop">[docs]</a>    <span class="k">def</span> <span class="nf">event_pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop the most recently saved events queue off the stack.</span>

<span class="sd">        Same as state_pop(), but does not restore EventProcessors&#39; state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Simulation.event_clear"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.event_clear">[docs]</a>    <span class="k">def</span> <span class="nf">event_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event_type</span><span class="o">=</span><span class="n">EPConnectionEvent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear out all scheduled events of the specified type.</span>

<span class="sd">        For instance, with event_type=EPConnectionEvent, this function can be used to ensure</span>
<span class="sd">        that no pending EPConnectionEvents will remain on the queue during some analysis</span>
<span class="sd">        or measurement operation.  One will usually want to do a state_push before using this</span>
<span class="sd">        function, then clear out the events that should be deleted, do the measurement or</span>
<span class="sd">        analysis, and then do state_pop to restore the original state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">events_temp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">event_type</span><span class="p">):</span>
                <span class="n">events_temp</span> <span class="o">=</span> <span class="n">events_temp</span> <span class="o">+</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events_temp</span>



    <span class="c"># Could just process src and dest in conn_params.</span>
    <span class="c"># Also could accept the connection already created, rather than</span>
    <span class="c"># creating one.</span></div>
<div class="viewcode-block" id="Simulation.connect"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.connect">[docs]</a>    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">src</span><span class="p">,</span><span class="n">dest</span><span class="p">,</span><span class="n">connection_type</span><span class="o">=</span><span class="n">EPConnection</span><span class="p">,</span><span class="o">**</span><span class="n">conn_params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect the src EventProcessor to the dest EventProcessor.</span>

<span class="sd">        The src and dest should be string names of existing EPs.</span>
<span class="sd">        Returns the connection that was created.  If the connection</span>
<span class="sd">        hasn&#39;t been given a name, it defaults to &#39;srcTodest&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conn_params</span><span class="p">:</span>
            <span class="c"># Might want to have a way of altering the name if this one&#39;s</span>
            <span class="c"># already in use. At the moment, an error is raised (correctly).</span>
            <span class="n">conn_params</span><span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="o">+</span><span class="s">&#39;To&#39;</span><span class="o">+</span><span class="n">dest</span>

        <span class="c"># Looks up src and dest in our dictionary of objects</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">connection_type</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">src</span><span class="p">],</span><span class="n">dest</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="n">dest</span><span class="p">],</span><span class="o">**</span><span class="n">conn_params</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">src</span><span class="p">]</span><span class="o">.</span><span class="n">_src_connect</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span><span class="o">.</span><span class="n">_dest_connect</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conn</span>

</div>
<div class="viewcode-block" id="Simulation.objects"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.objects">[docs]</a>    <span class="k">def</span> <span class="nf">objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">baseclass</span><span class="o">=</span><span class="n">EventProcessor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dictionary of simulation objects having the specified</span>
<span class="sd">        base class.  All simulation objects have a base class of</span>
<span class="sd">        EventProcessor, and so the baseclass must be either</span>
<span class="sd">        EventProcessor or one of its subclasses.</span>

<span class="sd">        If there is a simulator called s, you can type e.g.</span>
<span class="sd">        s.objects().keys() to see a list of the names of all objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">ep_name</span><span class="p">,</span><span class="n">ep</span><span class="p">)</span>
                     <span class="k">for</span> <span class="p">(</span><span class="n">ep_name</span><span class="p">,</span><span class="n">ep</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_processors</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ep</span><span class="p">,</span><span class="n">baseclass</span><span class="p">)])</span>

</div>
<div class="viewcode-block" id="Simulation.connections"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.connections">[docs]</a>    <span class="k">def</span> <span class="nf">connections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of all unique connections to or from any object.&quot;&quot;&quot;</span>
        <span class="c"># The return value cannot be a dictionary like objects(),</span>
        <span class="c"># because connection names are not guaranteed to be unique</span>
        <span class="n">connlists</span> <span class="o">=</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">in_connections</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">out_connections</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="c"># Flatten one level</span>
        <span class="n">conns</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="n">connlists</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cl</span><span class="p">:</span>
                <span class="n">conns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">conns</span><span class="p">)]</span>

</div>
<div class="viewcode-block" id="Simulation.script_repr"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.script_repr">[docs]</a>    <span class="k">def</span> <span class="nf">script_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">imports</span><span class="o">=</span><span class="p">[],</span><span class="n">prefix</span><span class="o">=</span><span class="s">&quot;    &quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a nearly runnable script recreating this simulation.</span>

<span class="sd">        Needs some work to make the result truly runnable.</span>

<span class="sd">        Only scheduled commands that have not yet been executed are</span>
<span class="sd">        included, because executed commands are not kept around.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objs</span>  <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">script_repr</span><span class="p">(</span><span class="n">imports</span><span class="o">=</span><span class="n">imports</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span>
                 <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="nb">cmp</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>

        <span class="c"># CBENHANCEMENT: could allow user to plug in a sorting</span>
        <span class="c"># function.  E.g. might want to compare conns based on name</span>
        <span class="c"># then dest then src if lots of conns share the same name (so</span>
        <span class="c"># the order is always the same).</span>
        <span class="n">conns</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">script_repr</span><span class="p">(</span><span class="n">imports</span><span class="o">=</span><span class="n">imports</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span>
                 <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(),</span>      <span class="nb">cmp</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">name</span><span class="p">))]</span>

        <span class="n">cmds</span>  <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">script_repr</span><span class="p">(</span><span class="n">imports</span><span class="o">=</span><span class="n">imports</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span>
                 <span class="nb">sorted</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">CommandEvent</span><span class="p">)],</span>
                               <span class="nb">cmp</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">command_string</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">command_string</span><span class="p">)),</span>
                        <span class="nb">cmp</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">time</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">time</span><span class="p">))]</span>

        <span class="c"># CEBALERT: hack to support importing the time type since the</span>
        <span class="c"># scheduled actions will have times printed using the</span>
        <span class="c"># time_type.</span>
        <span class="n">imports</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;from </span><span class="si">%s</span><span class="s"> import </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">time_type</span><span class="o">.</span><span class="n">__module__</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">time_type</span><span class="o">.</span><span class="n">__name__</span><span class="p">))</span>

        <span class="n">imps</span>  <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">imports</span><span class="p">))</span>

        <span class="n">vals</span>  <span class="o">=</span> <span class="p">[</span><span class="n">_simulation_path</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="s">&quot;=&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span>
                 <span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="s">&quot;startup_commands&quot;</span><span class="p">]</span>
                 <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p</span><span class="p">)]</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s"># Imports:</span><span class="se">\n\n</span><span class="s">&quot;</span>                <span class="o">+</span>     <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">imps</span><span class="p">)</span>  <span class="o">+</span> \
               <span class="s">&quot;</span><span class="se">\n\n\n</span><span class="s">&quot;</span>                            <span class="o">+</span>   <span class="s">&#39;</span><span class="se">\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>  <span class="o">+</span> \
               <span class="s">&#39;</span><span class="se">\n\n\n\n</span><span class="s"># Objects:</span><span class="se">\n\n</span><span class="s">&#39;</span>            <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>  <span class="o">+</span> \
               <span class="s">&#39;</span><span class="se">\n\n\n\n</span><span class="s"># Connections:</span><span class="se">\n\n</span><span class="s">&#39;</span>        <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n\n\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conns</span><span class="p">)</span> <span class="o">+</span> \
               <span class="s">&#39;</span><span class="se">\n\n\n\n</span><span class="s"># Scheduled commands:</span><span class="se">\n\n</span><span class="s">&#39;</span> <span class="o">+</span>     <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cmds</span><span class="p">)</span>


    <span class="c"># Convenience function for use in graphical editors of the simulation</span></div>
<div class="viewcode-block" id="Simulation.grid_layout"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.Simulation.grid_layout">[docs]</a>    <span class="k">def</span> <span class="nf">grid_layout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">objgrid</span><span class="p">,</span><span class="n">xstart</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">xstep</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="n">ystart</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">ystep</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="n">item_scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the layout_location of simulation objects in a grid pattern.</span>

<span class="sd">        Takes a list of lists of simulation objects, or names of</span>
<span class="sd">        simulation objects, and positions them with layout_locations</span>
<span class="sd">        left-to-right, top-to-bottom, starting at (xstart,ystart) and</span>
<span class="sd">        advancing by xstep and ystep.</span>

<span class="sd">        The object None can be placed in the grid to skip a grid space.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">item_scale</span><span class="o">=</span><span class="n">item_scale</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">ystart</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">objgrid</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">xstart</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">layout_location</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">layout_location</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="n">xstep</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">ystep</span>


</div></div>
<div class="viewcode-block" id="RealTimeSimulation"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.RealTimeSimulation">[docs]</a><span class="k">class</span> <span class="nc">RealTimeSimulation</span><span class="p">(</span><span class="n">Simulation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A (quasi) real-time simulation object.</span>

<span class="sd">    This subclass of Simulation attempts to maintain a correspondence</span>
<span class="sd">    between simulation time and real time, as defined by the timescale</span>
<span class="sd">    parameter.  Real time simulation instances still maintain a</span>
<span class="sd">    nominal, discrete simulation time that determines the order of</span>
<span class="sd">    event delivery.</span>

<span class="sd">    At the beginning of each simulation time epoch, the simulation</span>
<span class="sd">    marks the actual wall clock time.  After event delivery for that</span>
<span class="sd">    epoch has ended, the simulation calculates the amount of</span>
<span class="sd">    computation time used for event processing, and executes a real</span>
<span class="sd">    sleep for the remainder of the epoch.  If the computation time for</span>
<span class="sd">    the epoch exceeded the real time, a warning is issued and</span>
<span class="sd">    processing proceeds immediately to the next simulation time epoch.</span>


<span class="sd">    RUN HOOKS</span>

<span class="sd">    The simulation includes as parameters two lists of functions/callables,</span>
<span class="sd">    run_start_hooks and run_stop_hooks, that will be called</span>
<span class="sd">    immediately before and after event processing during a call to</span>
<span class="sd">    .run().  This allows, for example, starting and stopping of</span>
<span class="sd">    real-time devices that might use resources while the simulation is</span>
<span class="sd">    not running.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">timescale</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">None</span><span class="p">),</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">       The desired real length of one simulation time unit, in milliseconds.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">run_start_hooks</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">HookList</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">       A list of callable objects to be called on entry to .run(),</span>
<span class="s">       before any events are processed.&quot;&quot;&quot;</span><span class="p">)</span>


    <span class="n">run_stop_hooks</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">HookList</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[],</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">       A list of callable objects to be called on exit from .run()</span>
<span class="s">       after all events are processed.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RealTimeSimulation</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_real_timestamp</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_start_hooks</span><span class="p">:</span>
            <span class="n">h</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_real_timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_time</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RealTimeSimulation</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_stop_hooks</span><span class="p">:</span>
            <span class="n">h</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">real_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">*</span> <span class="mi">1000</span>

<div class="viewcode-block" id="RealTimeSimulation.sleep"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.simulation.RealTimeSimulation.sleep">[docs]</a>    <span class="k">def</span> <span class="nf">sleep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">delay</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sleep for the number of real milliseconds seconds corresponding to the</span>
<span class="sd">        given delay, subtracting off the amount of time elapsed since the</span>
<span class="sd">        last sleep.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sleep_ms</span> <span class="o">=</span> <span class="n">delay</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">timescale</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real_time</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_real_timestamp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sleep_ms</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Realtime fault. Sleep delay of </span><span class="si">%f</span><span class="s"> requires realtime sleep of </span><span class="si">%.2f</span><span class="s"> ms.&quot;</span>
                         <span class="o">%</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span><span class="n">sleep_ms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;sleeping. delay =&quot;</span><span class="p">,</span><span class="n">delay</span><span class="p">,</span><span class="s">&quot;real delay =&quot;</span><span class="p">,</span><span class="n">sleep_ms</span><span class="p">,</span><span class="s">&quot;ms.&quot;</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">sleep_ms</span><span class="o">/</span><span class="mf">1000.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_real_timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="n">delay</span>
</pre></div></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/topo-banner7.png" alt="Logo"/>
            </a></p>
<ul class="global-toc">

<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../News/index.html">News</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>
<li><a href="../../../Reference_Manual/index.html">Reference Manual</a></li>
<li><a href="../../../Developer_Manual/index.html">Developer Manual</a></li>
<li><a href="http://github.com/ioam/topographica">Github Source Code</a></li>
<li><a href="../../../Forums/index.html">Forums</a></li>
<li><a href="../../../Team_Members/index.html">Team Members</a></li>
<li><a href="../../../Future_Work/index.html">Future Work</a></li>
<li><a href="../../../FAQ/index.html">FAQ</a></li>
<li><a href="../../../Links/index.html">Links</a></li>
<li><a href="../../../Home/pubs.html">Publications</a></li>
<li><a href="../../../site_map.html">Site Map</a></li>
</ul>
<h3><a href="../../../index.html">Table Of Contents</a></h3>



<h3>This Page</h3>
<ul class="this-page-menu">
	<li><a	href="https://github.com/ioam/topographica/edit/master/doc/_modules/topo/base/simulation.rst" rel="nofollow">Edit on GitHub</a></li>
    <li><a	href="http://doozy.inf.ed.ac.uk:8010/builders/topographica_docs" rel="nofollow">Rebuild docs</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>

<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>



<li><ul class="parents">



          <li><a href="../../index.html" >Module code</a> &raquo;</li>

</ul></li>


      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, IOAM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>