<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>topo.base.cf &mdash; Topographica</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.9.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/custom.js"></script>
    <link rel="shortcut icon" href="../../../_static/topo-favicon.ico"/>
    <link rel="top" title="Topographica" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>

<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>



<li><ul class="parents">



          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li>

</ul></li>


      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for topo.base.cf</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">ConnectionField and associated classes.</span>

<span class="sd">This module defines some basic classes of objects used to create</span>
<span class="sd">simulations of cortical sheets that take input through connection</span>
<span class="sd">fields that project from other cortical sheets (or laterally from</span>
<span class="sd">themselves).</span>

<span class="sd">ConnectionField: Holds a single connection field within a</span>
<span class="sd">CFProjection.</span>

<span class="sd">CFProjection: A set of ConnectionFields mapping from a Sheet into a</span>
<span class="sd">ProjectionSheet.</span>

<span class="sd">CFSheet: A subclass of ProjectionSheet that provides an interface to</span>
<span class="sd">the underlying ConnectionFields in any projection of type</span>
<span class="sd">CFProjection.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">param</span>
<span class="kn">from</span> <span class="nn">holoviews</span> <span class="kn">import</span> <span class="n">Grid</span><span class="p">,</span> <span class="n">Dimension</span><span class="p">,</span> <span class="n">ViewMap</span>
<span class="kn">from</span> <span class="nn">holoviews.interface.collector</span> <span class="kn">import</span> <span class="n">AttrTree</span><span class="p">,</span> <span class="n">AttrDict</span>
<span class="kn">from</span> <span class="nn">holoviews.core</span> <span class="kn">import</span> <span class="n">BoundingBox</span><span class="p">,</span> <span class="n">BoundingRegionParameter</span><span class="p">,</span> <span class="n">Slice</span>

<span class="kn">import</span> <span class="nn">patterngenerator</span>
<span class="kn">from</span> <span class="nn">patterngenerator</span> <span class="kn">import</span> <span class="n">PatternGenerator</span>
<span class="kn">from</span> <span class="nn">functionfamily</span> <span class="kn">import</span> <span class="n">TransferFn</span><span class="p">,</span><span class="n">IdentityTF</span>
<span class="kn">from</span> <span class="nn">functionfamily</span> <span class="kn">import</span> <span class="n">LearningFn</span><span class="p">,</span><span class="n">Hebbian</span><span class="p">,</span><span class="n">IdentityLF</span>
<span class="kn">from</span> <span class="nn">functionfamily</span> <span class="kn">import</span> <span class="n">ResponseFn</span><span class="p">,</span><span class="n">DotProduct</span>
<span class="kn">from</span> <span class="nn">functionfamily</span> <span class="kn">import</span> <span class="n">CoordinateMapperFn</span><span class="p">,</span><span class="n">IdentityMF</span>
<span class="kn">from</span> <span class="nn">projection</span> <span class="kn">import</span> <span class="n">Projection</span><span class="p">,</span><span class="n">ProjectionSheet</span>
<span class="kn">from</span> <span class="nn">sheetview</span> <span class="kn">import</span> <span class="n">CFView</span>


<div class="viewcode-block" id="simple_vectorize"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.simple_vectorize">[docs]</a><span class="k">def</span> <span class="nf">simple_vectorize</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">num_outputs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">output_type</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for Numpy.vectorize to make it work properly with different Numpy versions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Numpy.vectorize returns a callable object that applies the given</span>
    <span class="c"># fn to a list or array.  By default, Numpy.vectorize will call</span>
    <span class="c"># the supplied fn an extra time to determine the output types,</span>
    <span class="c"># which is a big problem for any function with side effects.</span>
    <span class="c"># Supplying arguments is supposed to avoid the problem, but as of</span>
    <span class="c"># Numpy 1.6.1 (and apparently since at least 1.1.1) this feature</span>
    <span class="c"># was broken:</span>
    <span class="c">#</span>
    <span class="c"># $ ./topographica -c &quot;def f(x): print x&quot; -c &quot;import numpy&quot; -c &quot;numpy.vectorize(f,otypes=numpy.sctype2char(object)*1)([3,4])&quot;</span>
    <span class="c"># 3</span>
    <span class="c"># 3</span>
    <span class="c"># 4</span>
    <span class="c">#</span>
    <span class="c"># Numpy 1.7.0 seems to fix the problem:</span>
    <span class="c"># $ ./topographica -c &quot;def f(x): print x&quot; -c &quot;import numpy&quot; -c &quot;numpy.vectorize(f,otypes=numpy.sctype2char(object)*1)([3,4])&quot;</span>
    <span class="c"># 3</span>
    <span class="c"># 4</span>
    <span class="c">#</span>
    <span class="c"># To make it work with all versions of Numpy, we use</span>
    <span class="c"># numpy.vectorize as-is for versions &gt; 1.7.0, and a nasty hack for</span>
    <span class="c"># previous versions.</span>

    <span class="c"># Simple Numpy 1.7.0 version:</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">version</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">7</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">otypes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sctype2char</span><span class="p">(</span><span class="n">output_type</span><span class="p">)</span><span class="o">*</span><span class="n">num_outputs</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">)</span>

    <span class="c"># Otherwise, we have to mess with Numpy&#39;s internal data structures to make it work.</span>
    <span class="n">vfn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">)</span>
    <span class="n">vfn</span><span class="o">.</span><span class="n">nout</span><span class="o">=</span><span class="n">num_outputs</span> <span class="c"># number of outputs of fn</span>
    <span class="n">output_typecode</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sctype2char</span><span class="p">(</span><span class="n">output_type</span><span class="p">)</span>
    <span class="n">vfn</span><span class="o">.</span><span class="n">otypes</span><span class="o">=</span><span class="n">output_typecode</span><span class="o">*</span><span class="n">num_outputs</span> <span class="c"># typecodes of outputs of fn</span>
    <span class="kn">import</span> <span class="nn">inspect</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">fn_code</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">func_code</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span><span class="s">&#39;func_code&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">fn</span><span class="o">.</span><span class="n">__call__</span><span class="o">.</span><span class="n">func_code</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t find code of </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="n">fn</span><span class="p">)</span>

    <span class="n">fn_args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargs</span><span class="p">(</span><span class="n">fn_code</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">fn_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s">&#39;self&#39;</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">vfn</span><span class="o">.</span><span class="n">lastcallargs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">fn_args</span><span class="p">)</span><span class="o">-</span><span class="n">extra</span> <span class="c"># num args of fn</span>
    <span class="k">return</span> <span class="n">vfn</span>



<span class="c">#: Specified explicitly when creating weights matrix - required</span>
<span class="c">#: for optimized C functions.</span></div>
<span class="n">weight_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>


<div class="viewcode-block" id="NullCFError"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.NullCFError">[docs]</a><span class="k">class</span> <span class="nc">NullCFError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Error thrown when trying to create an empty CF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="nb">input</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">):</span>
        <span class="ne">ValueError</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&quot;ConnectionField at (</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">) (input_sheet=</span><span class="si">%s</span><span class="s">) has a zero-sized weights matrix (</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">); you may need to supply a larger bounds_template or increase the density of the sheet.&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="nb">input</span><span class="p">,</span><span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="ConnectionField"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.ConnectionField">[docs]</a><span class="k">class</span> <span class="nc">ConnectionField</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A set of weights on one input Sheet.</span>

<span class="sd">    Each ConnectionField contributes to the activity of one unit on</span>
<span class="sd">    the output sheet, and is normally used as part of a Projection</span>
<span class="sd">    including many other ConnectionFields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;weights&#39;</span><span class="p">,</span><span class="s">&#39;input_sheet_slice&#39;</span><span class="p">,</span><span class="s">&#39;mask&#39;</span><span class="p">,</span>
                 <span class="s">&#39;_has_norm_total&#39;</span><span class="p">,</span><span class="s">&#39;_norm_total&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__get_norm_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the stored norm_value, if any, or else the current sum of the weights.</span>
<span class="sd">        See the norm_total property for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The actual value is cached in _norm_total.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_norm_total</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm_total</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># CEBALERT: what was I playing with for this before?</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set_norm_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_norm_total</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set an explicit value to be returned by norm_total.</span>
<span class="sd">        See the norm_total property for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_norm_total</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm_total</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_norm_total</span>

    <span class="k">def</span> <span class="nf">__del_norm_total</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete any cached norm_total that may have been set.</span>
<span class="sd">        See the norm_total property for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_norm_total</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="c"># CB: Accessing norm_total as a property from the C code takes</span>
    <span class="c"># about 2% of run time for 90 iterations of lissom_oo_or. (As of</span>
    <span class="c"># r8139, using floating-point simulation time.)</span>
    <span class="n">norm_total</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_norm_total</span><span class="p">,</span><span class="n">__set_norm_total</span><span class="p">,</span><span class="n">__del_norm_total</span><span class="p">,</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The norm_total property returns a value useful in computing</span>
<span class="sd">        a sum-based weight normalization.</span>

<span class="sd">        By default, the value returned is simply the current sum of</span>
<span class="sd">        the connection weights.  However, another value can be</span>
<span class="sd">        substituted by setting norm_total explicitly, and this cached</span>
<span class="sd">        value will then be returned instead.</span>

<span class="sd">        This mechanism has two main purposes.  First, it allows a</span>
<span class="sd">        learning function to cache the sum value for an output</span>
<span class="sd">        function to use later without computation, which can result in</span>
<span class="sd">        significant time savings.  Second, the extra level of</span>
<span class="sd">        indirection allows the sum value to be manipulated before it</span>
<span class="sd">        is used, to implement operations like joint normalization</span>
<span class="sd">        across corresponding CFs in multiple Projections.</span>

<span class="sd">        Apart from such cases, norm_total can be ignored.</span>

<span class="sd">        Note that every person who uses a class that sets or gets</span>
<span class="sd">        norm_total must be very careful to ensure that stale values</span>
<span class="sd">        will never be accessed.  A good way to do this is to make sure</span>
<span class="sd">        that the value is only set just before it will be used, and</span>
<span class="sd">        deleted as soon as it has been accessed.</span>

<span class="sd">        WARNING: Any c-optimized code can bypass this property and</span>
<span class="sd">        access directly _has_norm_total, _norm_total</span>

<span class="sd">        &quot;&quot;&quot;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">input_sheet</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_sheet_slice</span><span class="o">.</span><span class="n">compute_bounds</span><span class="p">(</span><span class="n">input_sheet</span><span class="p">)</span>

    <span class="c"># Class attribute to switch to legacy weight generation if False</span>
    <span class="n">independent_weight_generation</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c"># CEBALERT:</span>
    <span class="c"># template and mask: usually created ONCE by CFProjection and</span>
    <span class="c"># specified as a Slice and array (respectively). Otherwise,</span>
    <span class="c"># can be specified as BoundingBox and patterngenerator.</span>

    <span class="c"># Note that BoundingBox() is ok for a default even though it&#39;s</span>
    <span class="c"># mutable because we copy it inside init.  Constant() is ok too</span>
    <span class="c"># because mask and weights_generator are not modified.</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">input_sheet</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">template</span><span class="o">=</span><span class="n">BoundingBox</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="mf">0.1</span><span class="p">),</span>
                 <span class="n">weights_generator</span><span class="o">=</span><span class="n">patterngenerator</span><span class="o">.</span><span class="n">Constant</span><span class="p">(),</span>
                 <span class="n">mask</span><span class="o">=</span><span class="n">patterngenerator</span><span class="o">.</span><span class="n">Constant</span><span class="p">(),</span>
                 <span class="n">output_fns</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">min_matrix_radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create weights at the specified (x,y) location on the</span>
<span class="sd">        specified input_sheet.</span>

<span class="sd">        The supplied template (if a BoundingRegion) is converted to a</span>
<span class="sd">        Slice, moved to the specified (x,y) location, and then the</span>
<span class="sd">        weights pattern is drawn inside by the weights_generator.</span>

<span class="sd">        Note that if the appropriate template Slice is already known,</span>
<span class="sd">        then it can be passed in instead of a BoundingRegion template.</span>
<span class="sd">        This slice will then be used directly, instead of converting</span>
<span class="sd">        the template into a Slice.</span>

<span class="sd">        The supplied template object itself will not be modified (it</span>
<span class="sd">        is copied before use).</span>

<span class="sd">        The mask allows the weights to be limited to being non-zero in</span>
<span class="sd">        a subset of the rectangular weights area.  The actual mask</span>
<span class="sd">        used is a view of the given mask created by cropping to the</span>
<span class="sd">        boundaries of the input_sheet, so that the weights all</span>
<span class="sd">        correspond to actual locations in the input sheet.  For</span>
<span class="sd">        instance, if a circular pattern of weights is desired, the</span>
<span class="sd">        mask should have a disk-shaped pattern of elements with value</span>
<span class="sd">        1, surrounded by elements with the value 0.  If the CF extends</span>
<span class="sd">        over the edge of the input sheet then the weights will</span>
<span class="sd">        actually be half-moon (or similar) rather than circular.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#print &quot;Create CF&quot;,input_sheet.name,x,y,&quot;template=&quot;,template,&quot;wg=&quot;,weights_generator,&quot;m=&quot;,mask,&quot;ofs=&quot;,output_fns,&quot;min r=&quot;,min_matrix_radius</span>

        <span class="n">template</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">template</span><span class="p">,</span><span class="n">Slice</span><span class="p">):</span>
            <span class="n">template</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="n">template</span><span class="p">,</span><span class="n">input_sheet</span><span class="p">,</span><span class="n">force_odd</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                             <span class="n">min_matrix_radius</span><span class="o">=</span><span class="n">min_matrix_radius</span><span class="p">)</span>

        <span class="c"># Note: if passed in, mask is shared between CFs (but not if created here)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="s">&#39;view&#39;</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">_create_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">template</span><span class="o">.</span><span class="n">compute_bounds</span><span class="p">(</span><span class="n">input_sheet</span><span class="p">),</span>
        <span class="c"># CEBALERT: it&#39;s not really worth adding more ALERTs on this</span>
        <span class="c"># topic, but...there&#39;s no way for the CF to control autosize</span>
        <span class="c"># and threshold.</span>
                               <span class="n">input_sheet</span><span class="p">,</span><span class="bp">True</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>


        <span class="c"># CB: has to be set for C code. Can&#39;t be initialized at the</span>
        <span class="c"># class level, or it would become a read-only class attribute</span>
        <span class="c"># (because it&#39;s a slot:</span>
        <span class="c"># http://docs.python.org/reference/datamodel.html). Can we</span>
        <span class="c"># somehow avoid having to think about _has_norm_total in the</span>
        <span class="c"># python code? Could the C code initialize this value?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_norm_total</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm_total</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">output_fns</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">output_fns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># CEBALERT: now even more confusing; weights_slice is</span>
        <span class="c"># different from input_sheet_slice. At least need to rename.</span>
        <span class="n">weights_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_input_sheet_slice</span><span class="p">(</span><span class="n">input_sheet</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">template</span><span class="p">,</span><span class="n">min_matrix_radius</span><span class="p">)</span>

        <span class="c"># CBNOTE: this would be clearer (but not perfect, and probably slower)</span>
        <span class="c"># m = mask_template[self.weights_slice()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">weights_slice</span><span class="o">.</span><span class="n">submatrix</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>  <span class="c"># view of original mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c"># CEBALERT: why is this necessary?</span>

        <span class="c"># (without it, optimized learning function creates artifacts in CFs at</span>
        <span class="c"># left and right edges of sheet, at some densities)</span>

        <span class="c"># CBENHANCEMENT: might want to do something about a size</span>
        <span class="c"># that&#39;s specified (right now the size is assumed to be that</span>
        <span class="c"># of the bounds)</span>
        <span class="c"># shouldn&#39;t be extra computation of boundingbox because it&#39;s gone from Slice.__init__; could avoid extra lookups by getting straight from slice</span>

        <span class="n">pattern_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">(</span><span class="n">input_sheet</span><span class="p">),</span>
                              <span class="n">xdensity</span><span class="o">=</span><span class="n">input_sheet</span><span class="o">.</span><span class="n">xdensity</span><span class="p">,</span>
                              <span class="n">ydensity</span><span class="o">=</span><span class="n">input_sheet</span><span class="o">.</span><span class="n">ydensity</span><span class="p">,</span>
                              <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>

        <span class="n">controlled_weights</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Dynamic</span><span class="o">.</span><span class="n">time_dependent</span>
                              <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Dynamic</span><span class="o">.</span><span class="n">time_fn</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">Time</span><span class="p">)</span>
                              <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">independent_weight_generation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">controlled_weights</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">param</span><span class="o">.</span><span class="n">Dynamic</span><span class="o">.</span><span class="n">time_fn</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                        <span class="c"># Initialize weights at time zero.</span>
                <span class="c"># Controls random streams</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">_CF (</span><span class="si">%.5f</span><span class="s">, </span><span class="si">%.5f</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">label</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">weights_generator</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">pattern_params</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">weights_generator</span><span class="p">(</span><span class="o">**</span><span class="n">pattern_params</span><span class="p">)</span>


        <span class="c"># CEBALERT: unnecessary copy! Pass type to PG &amp; have it draw</span>
        <span class="c"># in that.  (Should be simple, except making it work for all</span>
        <span class="c"># the PG subclasses that override array creation in various</span>
        <span class="c"># ways (producing or using inconsistent types) turned out to</span>
        <span class="c"># be too painful.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">weight_type</span><span class="p">)</span>

        <span class="c"># CEBHACKALERT: the system of masking through multiplication</span>
        <span class="c"># by 0 works for now, while the output_fns are all</span>
        <span class="c"># multiplicative.  But in the long run we need a better way to</span>
        <span class="c"># apply the mask.  The same applies anywhere the mask is used,</span>
        <span class="c"># including in learningfn/. We should investigate masked</span>
        <span class="c"># arrays (from numpy).</span>
        <span class="k">for</span> <span class="n">of</span> <span class="ow">in</span> <span class="n">output_fns</span><span class="p">:</span>
            <span class="n">of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>


    <span class="c"># CB: can this be renamed to something better?</span>
    <span class="k">def</span> <span class="nf">_create_input_sheet_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">input_sheet</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">template</span><span class="p">,</span><span class="n">min_matrix_radius</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the input_sheet_slice, which provides the appropriate</span>
<span class="sd">        Slice for this CF on the input_sheet (as well as providing</span>
<span class="sd">        this CF&#39;s exact bounds).</span>

<span class="sd">        Also creates the weights_slice, which provides the Slice for</span>
<span class="sd">        this weights matrix (in case it must be cropped at an edge).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># copy required because the template gets modified here but</span>
        <span class="c"># needs to be used again</span>
        <span class="n">input_sheet_slice</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
        <span class="n">input_sheet_slice</span><span class="o">.</span><span class="n">positionedcrop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">input_sheet</span><span class="p">)</span>
        <span class="n">input_sheet_slice</span><span class="o">.</span><span class="n">crop_to_sheet</span><span class="p">(</span><span class="n">input_sheet</span><span class="p">)</span>

        <span class="c"># weights matrix cannot have a zero-sized dimension (could</span>
        <span class="c"># happen at this stage because of cropping)</span>
        <span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span> <span class="o">=</span> <span class="n">input_sheet_slice</span><span class="o">.</span><span class="n">shape_on_sheet</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nrows</span><span class="o">&lt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">ncols</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NullCFError</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">input_sheet</span><span class="p">,</span><span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_sheet_slice</span> <span class="o">=</span> <span class="n">input_sheet_slice</span>

        <span class="c"># not copied because we don&#39;t use again</span>
        <span class="n">template</span><span class="o">.</span><span class="n">positionlesscrop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">input_sheet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">template</span>


    <span class="c"># CEBALERT: unnecessary method; can use something like</span>
    <span class="c"># activity[cf.input_sheet_slice()]</span>
    <span class="k">def</span> <span class="nf">get_input_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">activity</span><span class="p">):</span>
        <span class="c"># CBNOTE: again, this might be clearer (but probably slower):</span>
        <span class="c"># activity[self.input_sheet_slice()]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_sheet_slice</span><span class="o">.</span><span class="n">submatrix</span><span class="p">(</span><span class="n">activity</span><span class="p">)</span>


</div>
<div class="viewcode-block" id="CFPResponseFn"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPResponseFn">[docs]</a><span class="k">class</span> <span class="nc">CFPResponseFn</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map an input activity matrix into an output matrix using the CFs</span>
<span class="sd">    in a CFProjection.</span>

<span class="sd">    Objects in this hierarchy of callable function objects compute a</span>
<span class="sd">    response matrix when given an input pattern and a set of</span>
<span class="sd">    ConnectionField objects.  Typically used as part of the activation</span>
<span class="sd">    function for a neuron, computing activation for one Projection.</span>

<span class="sd">    Objects in this class must support being called as a function with</span>
<span class="sd">    the arguments specified below, and are assumed to modify the</span>
<span class="sd">    activity matrix in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__abstract</span><span class="o">=</span><span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">input_activity</span><span class="p">,</span> <span class="n">activity</span><span class="p">,</span> <span class="n">strength</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

</div>
<div class="viewcode-block" id="CFPRF_Plugin"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPRF_Plugin">[docs]</a><span class="k">class</span> <span class="nc">CFPRF_Plugin</span><span class="p">(</span><span class="n">CFPResponseFn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic large-scale response function based on a simple single-CF function.</span>

<span class="sd">    Applies the single_cf_fn to each CF in turn.  For the default</span>
<span class="sd">    single_cf_fn of DotProduct(), does a basic dot product of each CF with the</span>
<span class="sd">    corresponding slice of the input array.  This function is likely</span>
<span class="sd">    to be slow to run, but it is easy to extend with any arbitrary</span>
<span class="sd">    single-CF response function.</span>

<span class="sd">    The single_cf_fn must be a function f(X,W) that takes two</span>
<span class="sd">    identically shaped matrices X (the input) and W (the</span>
<span class="sd">    ConnectionField weights) and computes a scalar activation value</span>
<span class="sd">    based on those weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">single_cf_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">ResponseFn</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="n">DotProduct</span><span class="p">(),</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Accepts a ResponseFn that will be applied to each CF individually.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">input_activity</span><span class="p">,</span> <span class="n">activity</span><span class="p">,</span> <span class="n">strength</span><span class="p">):</span>
        <span class="n">single_cf_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cf_fn</span>
        <span class="k">for</span> <span class="n">cf</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">():</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">input_sheet_slice</span><span class="o">.</span><span class="n">submatrix</span><span class="p">(</span><span class="n">input_activity</span><span class="p">)</span>
            <span class="n">activity</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">single_cf_fn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">activity</span> <span class="o">*=</span> <span class="n">strength</span>

</div>
<div class="viewcode-block" id="CFPLearningFn"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPLearningFn">[docs]</a><span class="k">class</span> <span class="nc">CFPLearningFn</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute new CFs for a CFProjection based on input and output activity values.</span>

<span class="sd">    Objects in this hierarchy of callable function objects compute a</span>
<span class="sd">    new set of CFs when given input and output patterns and a set of</span>
<span class="sd">    ConnectionField objects.  Used for updating the weights of one</span>
<span class="sd">    CFProjection.</span>

<span class="sd">    Objects in this class must support being called as a function with</span>
<span class="sd">    the arguments specified below.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__abstract</span> <span class="o">=</span> <span class="bp">True</span>


<div class="viewcode-block" id="CFPLearningFn.constant_sum_connection_rate"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPLearningFn.constant_sum_connection_rate">[docs]</a>    <span class="k">def</span> <span class="nf">constant_sum_connection_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n_units</span><span class="p">,</span><span class="n">learning_rate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the learning rate for a single connection assuming that</span>
<span class="sd">        the total rate is to be divided evenly among all the units in</span>
<span class="sd">        the connection field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">learning_rate</span><span class="p">)</span><span class="o">/</span><span class="n">n_units</span>


    <span class="c"># JABALERT: Should the learning_rate be a parameter of this object instead of an argument?</span></div>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">input_activity</span><span class="p">,</span> <span class="n">output_activity</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply this learning function to the given set of ConnectionFields,</span>
<span class="sd">        and input and output activities, using the given learning_rate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

</div>
<div class="viewcode-block" id="CFPLF_Identity"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPLF_Identity">[docs]</a><span class="k">class</span> <span class="nc">CFPLF_Identity</span><span class="p">(</span><span class="n">CFPLearningFn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;CFLearningFunction performing no learning.&quot;&quot;&quot;</span>
    <span class="n">single_cf_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">LearningFn</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="n">IdentityLF</span><span class="p">(),</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">input_activity</span><span class="p">,</span> <span class="n">output_activity</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">pass</span>

</div>
<div class="viewcode-block" id="CFPLF_Plugin"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPLF_Plugin">[docs]</a><span class="k">class</span> <span class="nc">CFPLF_Plugin</span><span class="p">(</span><span class="n">CFPLearningFn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;CFPLearningFunction applying the specified single_cf_fn to each CF.&quot;&quot;&quot;</span>
    <span class="n">single_cf_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">LearningFn</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="n">Hebbian</span><span class="p">(),</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Accepts a LearningFn that will be applied to each CF individually.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="n">input_activity</span><span class="p">,</span> <span class="n">output_activity</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the specified single_cf_fn to every CF.&quot;&quot;&quot;</span>
        <span class="n">single_connection_learning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant_sum_connection_rate</span><span class="p">(</span><span class="n">iterator</span><span class="o">.</span><span class="n">proj_n_units</span><span class="p">,</span><span class="n">learning_rate</span><span class="p">)</span>
        <span class="c"># avoid evaluating these references each time in the loop</span>
        <span class="n">single_cf_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cf_fn</span>

        <span class="k">for</span> <span class="n">cf</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">():</span>
            <span class="n">single_cf_fn</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">get_input_matrix</span><span class="p">(</span><span class="n">input_activity</span><span class="p">),</span>
                         <span class="n">output_activity</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
                         <span class="n">single_connection_learning_rate</span><span class="p">)</span>
            <span class="n">cf</span><span class="o">.</span><span class="n">weights</span> <span class="o">*=</span> <span class="n">cf</span><span class="o">.</span><span class="n">mask</span>

</div>
<div class="viewcode-block" id="CFPOutputFn"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPOutputFn">[docs]</a><span class="k">class</span> <span class="nc">CFPOutputFn</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Type for an object that applies some operation (typically something</span>
<span class="sd">    like normalization) to all CFs in a CFProjection for which the specified</span>
<span class="sd">    mask (typically the activity at the destination of this projection)</span>
<span class="sd">    is nonzero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__abstract</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operate on each CF for which the mask is nonzero.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

</div>
<div class="viewcode-block" id="CFPOF_Plugin"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPOF_Plugin">[docs]</a><span class="k">class</span> <span class="nc">CFPOF_Plugin</span><span class="p">(</span><span class="n">CFPOutputFn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies the specified single_cf_fn to each CF in the CFProjection</span>
<span class="sd">    for which the mask is nonzero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">single_cf_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">TransferFn</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="n">IdentityTF</span><span class="p">(),</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Accepts a TransferFn that will be applied to each CF individually.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_cf_fn</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">IdentityTF</span><span class="p">:</span>
            <span class="n">single_cf_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_cf_fn</span>

            <span class="k">for</span> <span class="n">cf</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">():</span>
                <span class="n">single_cf_fn</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">cf</span><span class="o">.</span><span class="n">norm_total</span>

</div>
<div class="viewcode-block" id="CFPOF_Identity"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFPOF_Identity">[docs]</a><span class="k">class</span> <span class="nc">CFPOF_Identity</span><span class="p">(</span><span class="n">CFPOutputFn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CFPOutputFn that leaves the CFs unchanged.</span>

<span class="sd">    Must never be changed or subclassed, because it might never</span>
<span class="sd">    be called. (I.e., it could simply be tested for and skipped.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">single_cf_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">TransferFn</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="n">IdentityTF</span><span class="p">(),</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterator</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="c"># CB: need to make usage of &#39;src&#39; and &#39;input_sheet&#39; consistent between</span>
<span class="c"># ConnectionField and CFProjection (i.e. pick one of them).</span></div>
<div class="viewcode-block" id="CFProjection"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFProjection">[docs]</a><span class="k">class</span> <span class="nc">CFProjection</span><span class="p">(</span><span class="n">Projection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A projection composed of ConnectionFields from a Sheet into a ProjectionSheet.</span>

<span class="sd">    CFProjection computes its activity using a response_fn of type</span>
<span class="sd">    CFPResponseFn (typically a CF-aware version of mdot) and output_fns</span>
<span class="sd">    (typically none).  The initial contents of the</span>
<span class="sd">    ConnectionFields mapping from the input Sheet into the target</span>
<span class="sd">    ProjectionSheet are controlled by the weights_generator, cf_shape,</span>
<span class="sd">    and weights_output_fn parameters, while the location of the</span>
<span class="sd">    ConnectionField is controlled by the coord_mapper parameter.</span>

<span class="sd">    Any subclass has to implement the interface</span>
<span class="sd">    activate(self,input_activity) that computes the response from the</span>
<span class="sd">    input and stores it in the activity array.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">response_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">CFPResponseFn</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">CFPRF_Plugin</span><span class="p">(),</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&#39;Function for computing the Projection response to an input pattern.&#39;</span><span class="p">)</span>

    <span class="n">cf_type</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">ConnectionField</span><span class="p">,</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Type of ConnectionField to use when creating individual CFs.&quot;</span><span class="p">)</span>

    <span class="c"># JPHACKALERT: Not all support for null CFs has been implemented.</span>
    <span class="c"># CF plotting and C-optimized CFPxF_ functions need</span>
    <span class="c"># to be fixed to support null CFs without crashing.</span>
    <span class="n">allow_null_cfs</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Whether or not the projection can have entirely empty CFs&quot;</span><span class="p">)</span>

    <span class="n">nominal_bounds_template</span> <span class="o">=</span> <span class="n">BoundingRegionParameter</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="n">BoundingBox</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="mf">0.1</span><span class="p">),</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Bounds defining the Sheet area covered by a prototypical ConnectionField.</span>
<span class="s">        The true bounds will differ depending on the density (see create_slice_template()).&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">weights_generator</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">PatternGenerator</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">patterngenerator</span><span class="o">.</span><span class="n">Constant</span><span class="p">(),</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Generate initial weights values.&quot;</span><span class="p">)</span>

    <span class="n">cf_shape</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">PatternGenerator</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">patterngenerator</span><span class="o">.</span><span class="n">Constant</span><span class="p">(),</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&quot;Mask pattern to define the shape of the connection fields.&quot;</span><span class="p">)</span>

    <span class="n">same_cf_shape_for_all_cfs</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Whether or not to share a single cf_shape mask for all CFs.</span>
<span class="s">        If True, the cf_shape is evaluated only once and shared for</span>
<span class="s">        all CFs, which saves computation time and memory.  If False,</span>
<span class="s">        the cf_shape is evaluated once for each CF, allowing each to</span>
<span class="s">        have its own shape.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">learning_fn</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">CFPLearningFn</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">CFPLF_Plugin</span><span class="p">(),</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&#39;Function for computing changes to the weights based on one activation step.&#39;</span><span class="p">)</span>

    <span class="c"># JABALERT: Shouldn&#39;t learning_rate be owned by the learning_fn?</span>
    <span class="n">learning_rate</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">softbounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Amount of learning at each step for this projection, specified</span>
<span class="s">        in units that are independent of the density of each Sheet.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">weights_output_fns</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">HookList</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="n">CFPOF_Plugin</span><span class="p">()],</span>
        <span class="n">class_</span><span class="o">=</span><span class="n">CFPOutputFn</span><span class="p">,</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&#39;Functions applied to each CF after learning.&#39;</span><span class="p">)</span>

    <span class="n">strength</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Global multiplicative scaling applied to the Activity of this Sheet.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">coord_mapper</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">ClassSelector</span><span class="p">(</span><span class="n">CoordinateMapperFn</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">IdentityMF</span><span class="p">(),</span>
        <span class="n">doc</span><span class="o">=</span><span class="s">&#39;Function to map a projected coordinate into the target sheet.&#39;</span><span class="p">)</span>

    <span class="c"># CEBALERT: this is temporary (allows c++ matching in certain</span>
    <span class="c"># cases).  We will allow the user to override the mask size, but</span>
    <span class="c"># by offering a scaling parameter.</span>
    <span class="n">autosize_mask</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">precedence</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Topographica sets the mask size so that it is the same as the connection field&#39;s</span>
<span class="s">        size, unless this parameter is False - in which case the user-specified size of</span>
<span class="s">        the cf_shape is used. In normal usage of Topographica, this parameter should</span>
<span class="s">        remain True.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">mask_threshold</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">constant</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        If a unit is above this value in the cf_shape mask, it is</span>
<span class="s">        included; otherwise it is excluded from the mask.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">apply_output_fns_init</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Whether to apply the output function to connection fields (e.g. for</span>
<span class="s">        normalization) when the CFs are first created.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">min_matrix_radius</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">None</span><span class="p">),</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Enforced minimum for radius of weights matrix.</span>
<span class="s">        The default of 1 gives a minimum matrix of 3x3. 0 would</span>
<span class="s">        allow a 1x1 matrix.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">hash_format</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">String</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s">&quot;{name}-{src}-{dest}&quot;</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">       Format string to determine the hash value used to initialize</span>
<span class="s">       random weight generation. Format keys available include {name}</span>
<span class="s">       {src} and {dest}.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">precedence</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">initialize_cfs</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Projection with a set of cf_type objects</span>
<span class="sd">        (typically ConnectionFields), each located at the location</span>
<span class="sd">        in the source sheet corresponding to the unit in the target</span>
<span class="sd">        sheet. The cf_type objects are stored in the &#39;cfs&#39; array.</span>

<span class="sd">        The nominal_bounds_template specified may be altered: the</span>
<span class="sd">        bounds must be fitted to the Sheet&#39;s matrix, and the weights</span>
<span class="sd">        matrix must have odd dimensions. These altered bounds are</span>
<span class="sd">        passed to the individual connection fields.</span>

<span class="sd">        A mask for the weights matrix is constructed. The shape is</span>
<span class="sd">        specified by cf_shape; the size defaults to the size</span>
<span class="sd">        of the nominal_bounds_template.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CFProjection</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weights_generator</span><span class="o">.</span><span class="n">set_dynamic_time_fn</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">sublistattr</span><span class="o">=</span><span class="s">&#39;generators&#39;</span><span class="p">)</span>
        <span class="c"># get the actual bounds_template by adjusting a copy of the</span>
        <span class="c"># nominal_bounds_template to ensure an odd slice, and to be</span>
        <span class="c"># cropped to sheet if necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice_template</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_bounds_template</span><span class="p">),</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span><span class="n">force_odd</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                     <span class="n">min_matrix_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_matrix_radius</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_template</span><span class="o">.</span><span class="n">compute_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask_template</span> <span class="o">=</span> <span class="n">_create_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cf_shape</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds_template</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">autosize_mask</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_n_units</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">initialize_cfs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_cfs</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_output_fns_init</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_learn_output_fns</span><span class="p">(</span><span class="n">active_units_mask</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c">### JCALERT! We might want to change the default value of the</span>
        <span class="c">### input value to self.src.activity; but it fails, raising a</span>
        <span class="c">### type error. It probably has to be clarified why this is</span>
        <span class="c">### happening</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_buffer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">activity</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;cfs&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">views</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">views</span><span class="o">.</span><span class="n">CFs</span> <span class="o">=</span> <span class="n">AttrTree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">views</span><span class="o">.</span><span class="n">CFs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cf_grid</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">_cf_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">&quot;Create ProjectionGrid with the correct metadata.&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">({})</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">timestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">simulation</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                                 <span class="n">info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">proj_src_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">proj_dest_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span>


    <span class="k">def</span> <span class="nf">_generate_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">X</span><span class="p">,</span><span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">sheetcoords_of_idx_grid</span><span class="p">()</span>
        <span class="n">vectorized_coord_mapper</span> <span class="o">=</span> <span class="n">simple_vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord_mapper</span><span class="p">,</span>
                                                   <span class="n">num_outputs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                                   <span class="c"># CB: could switch to float32?</span>
                                                   <span class="n">output_type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vectorized_coord_mapper</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span>


    <span class="c"># CB: should be _initialize_cfs() since we already have &#39;initialize_cfs&#39; flag?</span>
    <span class="k">def</span> <span class="nf">_create_cfs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">vectorized_create_cf</span> <span class="o">=</span> <span class="n">simple_vectorize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_create_cf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cfs</span> <span class="o">=</span> <span class="n">vectorized_create_cf</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_coords</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flatcfs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfs</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_create_cf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a ConnectionField at x,y in the src sheet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># (to restore would need to have an r,c counter)</span>
        <span class="c"># self.debug(&quot;Creating CF(%d,%d) from src (%.3f,%.3f) to  dest (%.3f,%.3f)&quot;%(r,c,x_cf,y_cf,x,y))</span>

        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                        <span class="n">src</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                        <span class="n">dest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">_CF (</span><span class="si">%.5f</span><span class="s">, </span><span class="si">%.5f</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">label</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">same_cf_shape_for_all_cfs</span><span class="p">:</span>
                <span class="n">mask_template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_template</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask_template</span> <span class="o">=</span> <span class="n">_create_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cf_shape</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">bounds_template</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">autosize_mask</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">,</span>
                                             <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

            <span class="n">CF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cf_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                              <span class="n">template</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_slice_template</span><span class="p">,</span>
                              <span class="n">weights_generator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">weights_generator</span><span class="p">,</span>
                              <span class="n">mask</span><span class="o">=</span><span class="n">mask_template</span><span class="p">,</span>
                              <span class="n">min_matrix_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_matrix_radius</span><span class="p">,</span>
                              <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">NullCFError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_null_cfs</span><span class="p">:</span>
                <span class="n">CF</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

        <span class="k">return</span> <span class="n">CF</span>


    <span class="k">def</span> <span class="nf">_calc_n_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of unmasked units in a typical ConnectionField.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_template</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span>
                   <span class="c"># CEBALERT: if the mask_template is bigger than the</span>
                   <span class="c"># src sheet (e.g.  conn radius bigger than src</span>
                   <span class="c"># radius), return the size of the source sheet</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<div class="viewcode-block" id="CFProjection.cf"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFProjection.cf">[docs]</a>    <span class="k">def</span> <span class="nf">cf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the specified ConnectionField&quot;&quot;&quot;</span>
        <span class="c"># CB: should we offer convenience cf(x,y) (i.e. sheetcoords) method instead?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;CFProjection.cf(r,c) is deprecated: use cfs[r,c] instead&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="CFProjection.cf_bounds"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFProjection.cf_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">cf_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bounds of the specified ConnectionField.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">lbrt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">situated</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">xdensity</span><span class="p">,</span> <span class="n">ydensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">xdensity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">ydensity</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">lbrt</span><span class="p">()</span>
        <span class="n">half_x_unit</span> <span class="o">=</span> <span class="p">((</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="n">xdensity</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="n">half_y_unit</span> <span class="o">=</span> <span class="p">((</span><span class="n">t</span><span class="o">-</span><span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">ydensity</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
        <span class="k">if</span> <span class="n">lbrt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">half_x_unit</span><span class="p">,</span> <span class="n">b</span><span class="o">+</span><span class="n">half_y_unit</span><span class="p">,</span> <span class="n">r</span><span class="o">-</span><span class="n">half_x_unit</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">half_y_unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">closest_cell_center</span><span class="p">(</span><span class="n">lbrt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lbrt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">closest_cell_center</span><span class="p">(</span><span class="n">lbrt</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">lbrt</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cols</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">rows</span><span class="p">))</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>

        <span class="n">grid_items</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
            <span class="n">grid_items</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">situated</span><span class="o">=</span><span class="n">situated</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">grid_items</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;CFs&#39;</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;{label}&#39;</span><span class="p">]))</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">proj_src_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">proj_dest_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">timestamp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">simulation</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span>


<div class="viewcode-block" id="CFProjection.view"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFProjection.view">[docs]</a>    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sheet_x</span><span class="p">,</span> <span class="n">sheet_y</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">situated</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a single connection field Matrix, for the unit</span>
<span class="sd">        located nearest to sheet coordinate (sheet_x,sheet_y).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timestamp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">simulation</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">time_dim</span> <span class="o">=</span> <span class="n">Dimension</span><span class="p">(</span><span class="s">&quot;Time&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">Dynamic</span><span class="o">.</span><span class="n">time_fn</span><span class="o">.</span><span class="n">time_type</span><span class="p">)</span>
        <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">sheet2matrixidx</span><span class="p">(</span><span class="n">sheet_x</span><span class="p">,</span> <span class="n">sheet_y</span><span class="p">)</span>
        <span class="n">cf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">input_sheet_slice</span>
        <span class="n">situated_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">activity</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">situated_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
        <span class="n">roi_bounds</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">situated</span><span class="p">:</span>
            <span class="n">matrix_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">situated_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">matrix_data</span><span class="p">[</span><span class="n">r1</span><span class="p">:</span><span class="n">r2</span><span class="p">,</span> <span class="n">c1</span><span class="p">:</span><span class="n">c2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">situated_bounds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matrix_data</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">roi_bounds</span>

        <span class="n">sv</span> <span class="o">=</span> <span class="n">CFView</span><span class="p">(</span><span class="n">matrix_data</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">situated_bounds</span><span class="o">=</span><span class="n">situated_bounds</span><span class="p">,</span>
                    <span class="n">input_sheet_slice</span><span class="o">=</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">),</span> <span class="n">roi_bounds</span><span class="o">=</span><span class="n">roi_bounds</span><span class="p">,</span>
                    <span class="n">label</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span> <span class="s">&quot; CF Weights&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">&#39;CF Weight&#39;</span><span class="p">)</span>
        <span class="n">sv</span><span class="o">.</span><span class="n">metadata</span><span class="o">=</span><span class="n">AttrDict</span><span class="p">(</span><span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span>

        <span class="n">viewmap</span> <span class="o">=</span> <span class="n">ViewMap</span><span class="p">((</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">sv</span><span class="p">),</span> <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="n">time_dim</span><span class="p">])</span>
        <span class="n">viewmap</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">AttrDict</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="p">(</span><span class="n">sheet_x</span><span class="p">,</span> <span class="n">sheet_y</span><span class="p">),</span>
                                    <span class="n">dest_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                    <span class="n">precedence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">precedence</span><span class="p">,</span> <span class="n">proj_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                    <span class="n">src_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                    <span class="n">row_precedence</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="o">.</span><span class="n">row_precedence</span><span class="p">,</span>
                                    <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">viewmap</span>

</div>
    <span class="k">def</span> <span class="nf">get_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sheet_x</span><span class="p">,</span> <span class="n">sheet_y</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;Deprecated, call &#39;view&#39; method instead.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">sheet_x</span><span class="p">,</span> <span class="n">sheet_y</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">)</span>


<div class="viewcode-block" id="CFProjection.activate"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFProjection.activate">[docs]</a>    <span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">input_activity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Activate using the specified response_fn and output_fn.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_fns</span><span class="p">:</span>
            <span class="n">input_activity</span> <span class="o">=</span> <span class="n">input_activity</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iaf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_fns</span><span class="p">:</span>
            <span class="n">iaf</span><span class="p">(</span><span class="n">input_activity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_buffer</span> <span class="o">=</span> <span class="n">input_activity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activity</span> <span class="o">*=</span><span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response_fn</span><span class="p">(</span><span class="n">CFIter</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">input_activity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">activity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">strength</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">of</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_fns</span><span class="p">:</span>
            <span class="n">of</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activity</span><span class="p">)</span>


    <span class="c"># CEBALERT: should add active_units_mask to match</span>
    <span class="c"># apply_learn_output_fns.</span></div>
<div class="viewcode-block" id="CFProjection.learn"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFProjection.learn">[docs]</a>    <span class="k">def</span> <span class="nf">learn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a CFProjection, learn consists of calling the learning_fn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Learning is performed if the input_buffer has already been set,</span>
        <span class="c"># i.e. there is an input to the Projection.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">learning_fn</span><span class="p">(</span><span class="n">CFIter</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">input_buffer</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">activity</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>


    <span class="c"># CEBALERT: called &#39;learn&#39; output fns here, but called &#39;weights&#39; output fns</span>
    <span class="c"># elsewhere (mostly). Change all to &#39;learn&#39;?</span></div>
<div class="viewcode-block" id="CFProjection.apply_learn_output_fns"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFProjection.apply_learn_output_fns">[docs]</a>    <span class="k">def</span> <span class="nf">apply_learn_output_fns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">active_units_mask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the weights_output_fns to each unit.</span>

<span class="sd">        If active_units_mask is True, inactive units will be skipped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">of</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_output_fns</span><span class="p">:</span>
            <span class="n">of</span><span class="p">(</span><span class="n">CFIter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">active_units_mask</span><span class="o">=</span><span class="n">active_units_mask</span><span class="p">))</span>


    <span class="c"># CEBALERT: see gc alert in simulation.__new__</span></div>
    <span class="k">def</span> <span class="nf">_cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfs</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
            <span class="c"># cf could be None or maybe something else</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span><span class="s">&#39;input_sheet&#39;</span><span class="p">):</span>
                <span class="n">cf</span><span class="o">.</span><span class="n">input_sheet</span><span class="o">=</span><span class="bp">None</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span><span class="s">&#39;input_sheet_slice&#39;</span><span class="p">):</span>
                <span class="n">cf</span><span class="o">.</span><span class="n">input_sheet_slice</span><span class="o">=</span><span class="bp">None</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span><span class="s">&#39;weights_slice&#39;</span><span class="p">):</span>
                <span class="n">cf</span><span class="o">.</span><span class="n">weights_slice</span><span class="o">=</span><span class="bp">None</span>


    <span class="k">def</span> <span class="nf">n_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Could also count the input_sheet_slice</span>
        <span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cfs</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CFProjection</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">n_bytes</span><span class="p">()</span> <span class="o">+</span> \
               <span class="nb">sum</span><span class="p">([</span><span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">+</span>
                    <span class="n">cf</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">nbytes</span>
                    <span class="k">for</span> <span class="n">cf</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">CFIter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ignore_sheet_mask</span><span class="o">=</span><span class="bp">True</span><span class="p">)()])</span>


    <span class="k">def</span> <span class="nf">n_conns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Counts non-masked values, if mask is available; otherwise counts</span>
        <span class="c"># weights as connections if nonzero</span>
        <span class="n">rows</span><span class="p">,</span><span class="n">cols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cfs</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">((</span><span class="n">cf</span><span class="o">.</span><span class="n">mask</span> <span class="k">if</span> <span class="n">cf</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">cf</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">CFIter</span><span class="p">(</span><span class="bp">self</span><span class="p">)()])</span>


<span class="c"># CEB: have not yet decided proper location for this method</span>
<span class="c"># JAB: should it be in PatternGenerator?</span></div>
<span class="k">def</span> <span class="nf">_create_mask</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span><span class="n">bounds_template</span><span class="p">,</span><span class="n">sheet</span><span class="p">,</span>
                 <span class="n">autosize</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;Mask&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the mask (see ConnectionField.__init__()).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Calculate the size &amp; aspect_ratio of the mask if appropriate;</span>
    <span class="c"># mask size set to be that of the weights matrix</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="s">&#39;size&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">autosize</span><span class="p">:</span>
        <span class="n">l</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">bounds_template</span><span class="o">.</span><span class="n">lbrt</span><span class="p">()</span>
        <span class="n">shape</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">t</span><span class="o">-</span><span class="n">b</span>
        <span class="n">shape</span><span class="o">.</span><span class="n">aspect_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="n">shape</span><span class="o">.</span><span class="n">size</span>

    <span class="c"># Center mask to matrixidx center</span>
    <span class="n">center_r</span><span class="p">,</span><span class="n">center_c</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="n">sheet2matrixidx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">center_x</span><span class="p">,</span><span class="n">center_y</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="n">matrixidx2sheet</span><span class="p">(</span><span class="n">center_r</span><span class="p">,</span><span class="n">center_c</span><span class="p">)</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                  <span class="n">x</span><span class="o">=</span><span class="n">center_x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">center_y</span><span class="p">,</span>
                  <span class="n">bounds</span><span class="o">=</span><span class="n">bounds_template</span><span class="p">,</span>
                  <span class="n">xdensity</span><span class="o">=</span><span class="n">sheet</span><span class="o">.</span><span class="n">xdensity</span><span class="p">,</span>
                  <span class="n">ydensity</span><span class="o">=</span><span class="n">sheet</span><span class="o">.</span><span class="n">ydensity</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">Dynamic</span><span class="o">.</span><span class="n">time_fn</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">Time</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">param</span><span class="o">.</span><span class="n">Dynamic</span><span class="o">.</span><span class="n">time_fn</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                        <span class="c"># Initialize masks at time 0</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="o">&gt;=</span><span class="n">threshold</span><span class="p">,</span><span class="n">mask</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="c"># CB: unnecessary copy (same as for weights)</span>
    <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">weight_type</span><span class="p">)</span>



<div class="viewcode-block" id="CFIter"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFIter">[docs]</a><span class="k">class</span> <span class="nc">CFIter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterator to walk through all ConnectionFields of all neurons in</span>
<span class="sd">    the destination Sheet of the given CFProjection.  Each iteration</span>
<span class="sd">    yields the tuple (cf,i) where cf is the ConnectionField at</span>
<span class="sd">    position i in the projection&#39;s flatcfs list.</span>

<span class="sd">    If active_units_mask is True, inactive units will be skipped. If</span>
<span class="sd">    ignore_sheet_mask is True, even units excluded by the sheet mask</span>
<span class="sd">    will be included.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># CB: as noted elsewhere, rename active_units_mask (to e.g.</span>
    <span class="c"># ignore_inactive_units).</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cfprojection</span><span class="p">,</span><span class="n">active_units_mask</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">ignore_sheet_mask</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">flatcfs</span> <span class="o">=</span> <span class="n">cfprojection</span><span class="o">.</span><span class="n">flatcfs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activity</span> <span class="o">=</span> <span class="n">cfprojection</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">activity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">cfprojection</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cf_type</span> <span class="o">=</span> <span class="n">cfprojection</span><span class="o">.</span><span class="n">cf_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_n_units</span> <span class="o">=</span> <span class="n">cfprojection</span><span class="o">.</span><span class="n">n_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_skip_non_responding_units</span> <span class="o">=</span> <span class="n">cfprojection</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">allow_skip_non_responding_units</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">active_units_mask</span> <span class="o">=</span> <span class="n">active_units_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_sheet_mask</span> <span class="o">=</span> <span class="n">ignore_sheet_mask</span>

    <span class="k">def</span> <span class="nf">__nomask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># return an array indicating all units should be processed</span>

        <span class="c"># dtype for C functions.</span>
        <span class="c"># could just be flat.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">activity</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activity</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c"># CEBALERT: make _</span>
    <span class="k">def</span> <span class="nf">get_sheet_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_sheet_mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nomask</span><span class="p">()</span>

    <span class="c"># CEBALERT: make _ (and probably drop &#39;_mask&#39;).</span>
    <span class="k">def</span> <span class="nf">get_active_units_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_skip_non_responding_units</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_units_mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">activity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nomask</span><span class="p">()</span>

    <span class="c"># CEBALERT: rename?</span>
<div class="viewcode-block" id="CFIter.get_overall_mask"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFIter.get_overall_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_overall_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array indicating whether or not each unit should be</span>
<span class="sd">        processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># JPHACKALERT: Should really check for the existence of the</span>
        <span class="c"># mask, rather than checking its type. This is a hack to</span>
        <span class="c"># support higher-order projections whose dest is a CF, instead</span>
        <span class="c"># of a sheet.  The right thing to do is refactor so that CF</span>
        <span class="c"># masks and  SheetMasks are subclasses of an abstract Mask</span>
        <span class="c"># type so that they support the same interfaces.</span>
        <span class="c">#</span>
        <span class="c"># CEBALERT: put back when supporting neighborhood masking</span>
        <span class="c"># (though preferably do what Jeff suggests instead)</span>
<span class="c">#        if isinstance(self.proj.dest.mask,SheetMask):</span>
<span class="c">#            return get_active_units_mask()</span>
<span class="c">#        else:</span>

        <span class="c"># CB: note that it&#39;s faster for our optimized C functions to</span>
        <span class="c"># combine the masks themselves, rather than using this method.</span>
        <span class="n">sheet_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sheet_mask</span><span class="p">()</span>
        <span class="n">active_units_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_units_mask</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">sheet_mask</span><span class="p">,</span><span class="n">active_units_mask</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_overall_mask</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">cf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatcfs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">yield</span> <span class="n">cf</span><span class="p">,</span><span class="n">i</span>


<span class="c"># PRALERT: CFIter Alias for backwards compatability with user code</span>
<span class="c"># Should be removed before release v1.0</span></div>
<span class="n">MaskedCFIter</span> <span class="o">=</span> <span class="n">CFIter</span>

<span class="c">### We don&#39;t really need this class; its methods could probably be</span>
<span class="c">### moved up to ProjectionSheet, because they may in fact be valid for</span>
<span class="c">### all ProjectionSheets. But we&#39;re leaving it here, because it is</span>
<span class="c">### likely to be useful in the future.</span>
<div class="viewcode-block" id="CFSheet"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFSheet">[docs]</a><span class="k">class</span> <span class="nc">CFSheet</span><span class="p">(</span><span class="n">ProjectionSheet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ProjectionSheet providing access to the ConnectionFields in its CFProjections.</span>

<span class="sd">    CFSheet is a Sheet built from units indexed by Sheet coordinates</span>
<span class="sd">    (x,y).  Each unit can have one or more ConnectionFields on another</span>
<span class="sd">    Sheet (via this sheet&#39;s CFProjections).  Thus CFSheet is a more</span>
<span class="sd">    concrete version of a ProjectionSheet; a ProjectionSheet does not</span>
<span class="sd">    require that there be units or weights of any kind.  Unless you</span>
<span class="sd">    need access to the underlying ConnectionFields for visualization</span>
<span class="sd">    or analysis, CFSheet and ProjectionSheet are interchangeable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">measure_maps</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Boolean</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span><span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">        Whether to include this Sheet when measuring various maps to create SheetViews.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">precedence</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>


<div class="viewcode-block" id="CFSheet.update_unit_view"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.CFSheet.update_unit_view">[docs]</a>    <span class="k">def</span> <span class="nf">update_unit_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">proj_name</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates the list of UnitView objects for a particular unit in this CFSheet.</span>
<span class="sd">        (There is one UnitView for each Projection to this CFSheet).</span>

<span class="sd">        Each UnitView is then added to the sheet_views of its source sheet.</span>
<span class="sd">        It returns the list of all UnitViews for the given unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">CFProjection</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Skipping non-CFProjection &quot;</span><span class="o">+</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">proj_name</span> <span class="o">==</span> <span class="s">&#39;&#39;</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">==</span><span class="n">proj_name</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
                <span class="n">cfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">views</span><span class="o">.</span><span class="n">CFs</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cfs</span><span class="p">:</span>
                    <span class="n">cfs</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">_cf_grid</span><span class="p">()</span>
                <span class="n">cfs</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>



</div></div>
<div class="viewcode-block" id="ResizableCFProjection"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.ResizableCFProjection">[docs]</a><span class="k">class</span> <span class="nc">ResizableCFProjection</span><span class="p">(</span><span class="n">CFProjection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A CFProjection with resizable weights.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Less efficient memory usage than CFProjection because it stores</span>
    <span class="c"># the (x,y) position of each ConnectionField.</span>


    <span class="k">def</span> <span class="nf">_generate_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># same as super&#39;s, but also stores the coords.</span>

        <span class="c"># CB: this is storing redundant info because generate_coords()</span>
        <span class="c"># returns output from mgrid. Might be better to store the 1d x</span>
        <span class="c"># and y coords, and generate the grids when needed?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X_cf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_cf</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ResizableCFProjection</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_generate_coords</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_cf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_cf</span>


    <span class="c">### This could be changed into a special __set__ method for</span>
    <span class="c">### bounds_template, instead of being a separate function, but</span>
    <span class="c">### having it be explicit like this might be clearer.</span>
    <span class="c">###</span>
    <span class="c">### This implementation is fairly slow, and for some algorithms</span>
    <span class="c">### that rely on changing the bounds frequently, it may be worth</span>
    <span class="c">### re-implementing it in C.</span>
<div class="viewcode-block" id="ResizableCFProjection.change_bounds"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.ResizableCFProjection.change_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">change_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nominal_bounds_template</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the bounding box for all of the ConnectionFields in this Projection.</span>

<span class="sd">        Calls change_bounds() on each ConnectionField.</span>

<span class="sd">        Currently only allows reducing the size, but should be</span>
<span class="sd">        extended to allow increasing as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slice_template</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="n">nominal_bounds_template</span><span class="p">),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span><span class="n">force_odd</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                               <span class="n">min_matrix_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_matrix_radius</span><span class="p">)</span>

        <span class="n">bounds_template</span> <span class="o">=</span> <span class="n">slice_template</span><span class="o">.</span><span class="n">compute_bounds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_template</span><span class="o">.</span><span class="n">containsbb_exclusive</span><span class="p">(</span><span class="n">bounds_template</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds_template</span><span class="o">.</span><span class="n">containsbb_inclusive</span><span class="p">(</span><span class="n">bounds_template</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;Initial and final bounds are the same.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&#39;Unable to change_bounds; currently allows reducing only.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c"># it&#39;s ok so we can store the bounds and resize the weights</span>
        <span class="n">mask_template</span> <span class="o">=</span> <span class="n">_create_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cf_shape</span><span class="p">,</span><span class="n">bounds_template</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">autosize_mask</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_threshold</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask_template</span> <span class="o">=</span> <span class="n">mask_template</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_n_units</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nominal_bounds_template</span> <span class="o">=</span> <span class="n">nominal_bounds_template</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_template</span> <span class="o">=</span> <span class="n">bounds_template</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slice_template</span> <span class="o">=</span> <span class="n">slice_template</span>

        <span class="n">cfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfs</span>
        <span class="n">rows</span><span class="p">,</span><span class="n">cols</span> <span class="o">=</span> <span class="n">cfs</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">output_fns</span> <span class="o">=</span> <span class="p">[</span><span class="n">wof</span><span class="o">.</span><span class="n">single_cf_fn</span> <span class="k">for</span> <span class="n">wof</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights_output_fns</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">xcf</span><span class="p">,</span><span class="n">ycf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">X_cf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">c</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">Y_cf</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="c"># CB: listhack - loop is candidate for replacement by numpy fn</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_change_cf_bounds</span><span class="p">(</span><span class="n">cfs</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">],</span><span class="n">input_sheet</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src</span><span class="p">,</span>
                                       <span class="n">x</span><span class="o">=</span><span class="n">xcf</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">ycf</span><span class="p">,</span>
                                       <span class="n">template</span><span class="o">=</span><span class="n">slice_template</span><span class="p">,</span>
                                       <span class="n">mask</span><span class="o">=</span><span class="n">mask_template</span><span class="p">,</span>
                                       <span class="n">output_fns</span><span class="o">=</span><span class="n">output_fns</span><span class="p">,</span>
                                       <span class="n">min_matrix_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_matrix_radius</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ResizableCFProjection.change_density"><a class="viewcode-back" href="../../../Reference_Manual/topo.base.html#topo.base.cf.ResizableCFProjection.change_density">[docs]</a>    <span class="k">def</span> <span class="nf">change_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_wt_density</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescales the weight matrix in place, interpolating or resampling as needed.</span>

<span class="sd">        Not yet implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

</div>
    <span class="k">def</span> <span class="nf">_change_cf_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">cf</span><span class="p">,</span><span class="n">input_sheet</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">template</span><span class="p">,</span><span class="n">mask</span><span class="p">,</span><span class="n">output_fns</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">min_matrix_radius</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the bounding box for this ConnectionField.</span>

<span class="sd">        Discards weights or adds new (zero) weights as necessary,</span>
<span class="sd">        preserving existing values where possible.</span>

<span class="sd">        Currently only supports reducing the size, not increasing, but</span>
<span class="sd">        should be extended to support increasing as well.</span>

<span class="sd">        Note that the supplied template will be modified, so if you&#39;re</span>
<span class="sd">        also using them elsewhere you should pass copies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_fns</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">output_fns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># CEBALERT: re-write to allow arbitrary resizing</span>
        <span class="n">or1</span><span class="p">,</span><span class="n">or2</span><span class="p">,</span><span class="n">oc1</span><span class="p">,</span><span class="n">oc2</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">input_sheet_slice</span>

        <span class="n">weights_slice</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">_create_input_sheet_slice</span><span class="p">(</span><span class="n">input_sheet</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">copy</span><span class="p">(</span><span class="n">template</span><span class="p">),</span><span class="n">min_matrix_radius</span><span class="p">)</span>

        <span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">,</span><span class="n">c1</span><span class="p">,</span><span class="n">c2</span> <span class="o">=</span> <span class="n">cf</span><span class="o">.</span><span class="n">input_sheet_slice</span>


        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r1</span> <span class="o">==</span> <span class="n">or1</span> <span class="ow">and</span> <span class="n">r2</span> <span class="o">==</span> <span class="n">or2</span> <span class="ow">and</span> <span class="n">c1</span> <span class="o">==</span> <span class="n">oc1</span> <span class="ow">and</span> <span class="n">c2</span> <span class="o">==</span> <span class="n">oc2</span><span class="p">):</span>
            <span class="c"># CB: note that it&#39;s faster to copy (i.e. replacing copy=1 with copy=0</span>
            <span class="c"># below slows down change_bounds().</span>
            <span class="n">cf</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">r1</span><span class="o">-</span><span class="n">or1</span><span class="p">:</span><span class="n">r2</span><span class="o">-</span><span class="n">or1</span><span class="p">,</span><span class="n">c1</span><span class="o">-</span><span class="n">oc1</span><span class="p">:</span><span class="n">c2</span><span class="o">-</span><span class="n">oc1</span><span class="p">],</span><span class="n">copy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c"># (so the obvious choice,</span>
            <span class="c"># cf.weights=cf.weights[r1-or1:r2-or1,c1-oc1:c2-oc1],</span>
            <span class="c"># is also slower).</span>

            <span class="n">cf</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">weights_slice</span><span class="o">.</span><span class="n">submatrix</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">cf</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="n">copy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c"># CB: why&#39;s this necessary?</span>
                                                <span class="c"># (see ALERT in __init__)</span>
            <span class="n">cf</span><span class="o">.</span><span class="n">weights</span> <span class="o">*=</span> <span class="n">cf</span><span class="o">.</span><span class="n">mask</span>
            <span class="k">for</span> <span class="n">of</span> <span class="ow">in</span> <span class="n">output_fns</span><span class="p">:</span>
                <span class="n">of</span><span class="p">(</span><span class="n">cf</span><span class="o">.</span><span class="n">weights</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">cf</span><span class="o">.</span><span class="n">norm_total</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/topo-banner7.png" alt="Logo"/>
            </a></p>
<ul class="global-toc">

<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../News/index.html">News</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>
<li><a href="../../../Reference_Manual/index.html">Reference Manual</a></li>
<li><a href="../../../Developer_Manual/index.html">Developer Manual</a></li>
<li><a href="http://github.com/ioam/topographica">Github Source Code</a></li>
<li><a href="../../../Forums/index.html">Forums</a></li>
<li><a href="../../../Team_Members/index.html">Team Members</a></li>
<li><a href="../../../Future_Work/index.html">Future Work</a></li>
<li><a href="../../../FAQ/index.html">FAQ</a></li>
<li><a href="../../../Links/index.html">Links</a></li>
<li><a href="../../../Home/pubs.html">Publications</a></li>
<li><a href="../../../site_map.html">Site Map</a></li>
</ul>
<h3><a href="../../../index.html">Table Of Contents</a></h3>



<h3>This Page</h3>
<ul class="this-page-menu">
	<li><a	href="https://github.com/ioam/topographica/edit/master/doc/_modules/topo/base/cf.rst" rel="nofollow">Edit on GitHub</a></li>
    <li><a	href="http://doozy.inf.ed.ac.uk:8010/builders/topographica_docs" rel="nofollow">Rebuild docs</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>

<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>



<li><ul class="parents">



          <li><a href="../../index.html" >Module code</a> &raquo;</li>

</ul></li>


      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, IOAM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>